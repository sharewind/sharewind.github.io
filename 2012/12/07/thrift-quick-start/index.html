<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="keywords" content=" 耐克赤足系列 耐克赤足2.0 3.0 4.0 5.0 7.0 耐克赤足跑鞋 耐克赤足二代 耐克编织跑鞋 耐克飞线系列 耐克飞线彩虹 耐克飞线气垫      耐克飞线价格 耐克飞线2014 耐克飞线鞋 耐克飞线登月 耐克飞线科技 耐克飞线2015 耐克登月系列 耐克登月3 4 5 6耐克登月系列跑步鞋 耐克阿甘鞋 耐克2013气垫鞋        耐克2014全掌气垫鞋 耐克2015气垫鞋 耐克max90高板反毛皮跑鞋" />
  <meta name="description" content="莆田批发高仿真标耐克系列跑鞋 耐克赤足滴塑新科技超轻NIKE FREE 5.0 耐克Nike Roshe Flyknit新款跑鞋 耐克2013磨砂皮            耐克赤足Nike Free 4.0 Flyknit赤足跑鞋 耐克登月6跑鞋 耐克2013男鞋 Nike Solarsoft Moccasin Woven 编织纹 超轻跑步鞋太阳神反毛皮 耐克2014飞线 耐克2015飞线      耐克登月NIKE FLYKNIT LUNAR2+编织版  耐克2013 耐克20K6代 7代 耐克87代系列轻量跑鞋" />
  
  <title>thrift 快速入门 | sharewind coder blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="####一、简介  thrift 是facebook 开源的跨语言、可扩展的RPC框架，实现了完整的软件栈，包括利用生成代码的引擎来构建高效的服务，支持C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js,">
<meta property="og:type" content="article">
<meta property="og:title" content="thrift 快速入门">
<meta property="og:url" content="http://yoursite.com/2012/12/07/thrift-quick-start/index.html">
<meta property="og:site_name" content="sharewind coder blog">
<meta property="og:description" content="####一、简介  thrift 是facebook 开源的跨语言、可扩展的RPC框架，实现了完整的软件栈，包括利用生成代码的引擎来构建高效的服务，支持C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, OCaml , Delphi 等语言。 thrift 类">
<meta property="og:image" content="http://yoursite.com/pics/thrift_stack.png">
<meta property="og:updated_time" content="2014-03-20T03:06:15.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="thrift 快速入门">
<meta name="twitter:description" content="####一、简介  thrift 是facebook 开源的跨语言、可扩展的RPC框架，实现了完整的软件栈，包括利用生成代码的引擎来构建高效的服务，支持C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, OCaml , Delphi 等语言。 thrift 类">
<meta name="twitter:image" content="http://yoursite.com/pics/thrift_stack.png">
  
    <link rel="alternate" href="/atom.xml" title="sharewind coder blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">sharewind coder blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-thrift-quick-start" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2012/12/07/thrift-quick-start/" class="article-date">
  <time datetime="2012-12-07T12:34:00.000Z" itemprop="datePublished">2012-12-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/thrift/">thrift</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      thrift 快速入门
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>####一、简介 </p>
<p>thrift 是facebook 开源的跨语言、可扩展的RPC框架，实现了完整的软件栈，包括利用生成代码的引擎来构建高效的服务，支持C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, OCaml , Delphi 等语言。</p>
<p>thrift 类似ICE、Protobuf 等框架，使用后缀名为.thrift 的 <strong>接口定义</strong>（interface definition）文件来定义thrift 的数据结构与服务接口。定义的服务接口由服务端实现，可以被客户端所调用。可以根据你所使用的语言，生成相应的代码文件。使用如下命令生成：</p>
<pre><code>thrift --gen &lt;language&gt; &lt;Thrift filename&gt;
</code></pre><p>####二、thrift 架构</p>
<p>thrift = RPC + Serialization，类似于Java的Hession 或RMI，不过thrift支持跨语言。<br>根据接口定义文件，可以根据不同的语言生成不同的的基础代码，来快速构建跨语言的分布式服务。</p>
<p><img src="/pics/thrift_stack.png" alt=""></p>
<p>thrift 层次</p>
<ol>
<li>Your Code: 你的业务代码，具体服务实现的业务逻辑</li>
<li>FooService.Client/ FooService.Processor: 是thrift 生成的代码，我们通过访问生成的Client来实现远程RPC调用，通过实现 定义中的接口，而成为一个Processor 的具体处理类。</li>
<li>Foo.write()/read(): 根据定义的结构体来向协议层TProtocol 读出或写入数据，相当于实现 对象的序列化与反序列化。</li>
<li>TProtocol：传输协议层</li>
<li>TTransport: 传输层</li>
<li>Underlying I/O: 底层IO</li>
</ol>
<p>引用官方的层次图 <a href="http://thrift.apache.org/docs/concepts/" target="_blank" rel="noopener">http://thrift.apache.org/docs/concepts/</a></p>
<pre>
      +-------------------------------------------+
      | Server                                    |
      | (single-threaded, event-driven etc)       |
      +-------------------------------------------+
      | Processor                                 |
      | (compiler generated)                      |
      +-------------------------------------------+
      | Protocol                                  |
      | (JSON, compact etc)                       |
      +-------------------------------------------+
      | Transport                                 |
      | (raw TCP, HTTP etc)                       |
      +-------------------------------------------+
</pre>

<p>#####Transport</p>
<p>TTransport层提供对网络IO读取或写入的简单封装，能够让thrift 与系统其它部分解耦。<br><strong>Transport 的接口</strong></p>
<ul>
<li>open</li>
<li>close</li>
<li>read</li>
<li>write</li>
<li>flush</li>
</ul>
<p>在Transport 的基础上，thrift 在服务端使用ServerTransport为新建立的连接创建原始传输对象。</p>
<p><strong>ServerTransport的接口</strong></p>
<ul>
<li>open</li>
<li>listen</li>
<li>accept</li>
<li>close</li>
</ul>
<p>传输层的类型</p>
<ul>
<li>TSocket- 使用堵塞式I/O进行传输，也是最常见的模式。</li>
<li>TFramedTransport- 使用非阻塞方式，按块的大小，进行传输，类似于Java中的NIO。</li>
<li>TFileTransport- 顾名思义按照文件的方式进程传输，虽然这种方式不提供Java的实现，但是实现起来非常简单。</li>
<li>TMemoryTransport- 使用内存I/O，就好比Java中的ByteArrayOutputStream实现。</li>
<li>TZlibTransport- 使用执行zlib压缩，不提供Java的实现。</li>
</ul>
<p>#####Protocol</p>
<p>TProtocol传输协议用来指定数据序列化的格式，例如JSON，XML或是压缩的二进流等。<br><strong>TProtocol接口定义</strong>：</p>
<pre><code>writeMessageBegin(name, type, seq)
writeMessageEnd()
writeStructBegin(name)
writeStructEnd()
writeFieldBegin(name, type, id)
writeFieldEnd()
writeFieldStop()
writeMapBegin(ktype, vtype, size)
writeMapEnd()
writeListBegin(etype, size)
writeListEnd()
writeSetBegin(etype, size)
writeSetEnd()
writeBool(bool)
writeByte(byte)
writeI16(i16)
writeI32(i32)
writeI64(i64)
writeDouble(double)
writeString(string)

name, type, seq = readMessageBegin()
                  readMessageEnd()
name = readStructBegin()
       readStructEnd()
name, type, id = readFieldBegin()
                 readFieldEnd()
k, v, size = readMapBegin()
             readMapEnd()
etype, size = readListBegin()
              readListEnd()
etype, size = readSetBegin()
              readSetEnd()
bool = readBool()
byte = readByte()
i16 = readI16()
i32 = readI32()
i64 = readI64()
double = readDouble()
string = readString()
</code></pre><p>传输协议的类型：</p>
<ul>
<li>TBinaryProtocol – 二进制编码格式进行数据传输。</li>
<li>TCompactProtocol – 这种协议非常有效的，使用Variable-Length Quantity (VLQ) 编码对数据进行压缩。</li>
<li>TJSONProtocol – 使用JSON的数据编码协议进行数据传输。</li>
<li>TSimpleJSONProtocol – 这种节约只提供JSON只写的协议，适用于通过脚本语言解析</li>
<li>TDebugProtocol – 在开发的过程中帮助开发人员调试用的，以文本的形式展现方便阅读。</li>
</ul>
<p>#####Scheme</p>
<p>Scheme 实现序列化、反序列化的接口中。每个Thrift对象（包括输入参数、返回值）都实现该方法，从而达到序列化到指定的协议中去，或者从指定的协议中读出对象。</p>
<pre><code>public interface IScheme&lt;T extends TBase&gt; {

  public void read(org.apache.thrift.protocol.TProtocol iproto, T struct) throws org.apache.thrift.TException;

  public void write(org.apache.thrift.protocol.TProtocol oproto, T struct) throws org.apache.thrift.TException;

}    

public interface SchemeFactory {    
  public &lt;S extends IScheme&gt; S getScheme();    
}

public abstract class StandardScheme&lt;T extends TBase&gt; implements IScheme&lt;T&gt; {

}
</code></pre><p>#####Processor</p>
<p>Processor 用来服务端收到请求后，对传入的数据进行读取后，再写入到输出中。具体就是在服务端收到数据包后，根据输入协议TProtocol in 读取相应请求的方法和参数，调用具体实现服务的业务逻辑后，再将返回的结果写入TProtocol out中。</p>
<pre><code>interface TProcessor {
    bool process(TProtocol in, TProtocol out) throws TException
}
</code></pre><p>Processor 由代码生成器根据不同的语言环境生成。</p>
<p>#####Server 服务端</p>
<p>Server的处理流程如下</p>
<ul>
<li>创建一个服务端的传输transport</li>
<li>创建用来输入和输出的transport </li>
<li>创建基于传输协议protocol 上的processor(代理到相应的业务方法)</li>
<li>等待客户端连接，并把请求转发给processor </li>
</ul>
<p>服务端类型</p>
<ul>
<li>TSimpleServer  单线程服务器端使用标准的堵塞式I/O。</li>
<li>TThreadPoolServer  多线程服务器端使用标准的堵塞式I/O。</li>
<li>TNonblockingServer – 多线程服务器端使用非堵塞式I/O，并且实现了Java中的NIO通道。</li>
<li>THsHaServer -（半同步/半异步的server）就应运而生了。它使用一个单独的线程来处理网络I/O，一个独立的worker线程池来处理消息。</li>
<li>TThreadedSelectorServer允许你用多个线程来处理网络I/O。它维护了两个线程池，一个用来处理网络I/O，另一个用来进行请求的处理。</li>
</ul>
<h4 id="三、利用thrift文件生成java环境的文件"><a href="#三、利用thrift文件生成java环境的文件" class="headerlink" title="三、利用thrift文件生成java环境的文件"></a>三、利用thrift文件生成java环境的文件</h4><p>thrift服务接口定义文件</p>
<pre><code>// usage
// for java:
// cd ${project_path}
// thrift -gen java -out ./src/main/java ./src/main/thrift/user.thrift

namespace java com.cjf.practice // 指定生成java 文件的包名
namespace py com.cjf.practice

const string VERSION = &quot;1.0.0&quot; // 定义一个常量（非必须）

// 定义一个结构体，相当于Java中的领域对象
struct UserProfile {
    1: i32 uid,
    2: string name,
    3: string blurb
}

// 定义服务接口
service UserStorage {
    void store(1: UserProfile user),
    UserProfile retrieve(1: i32 uid)
}
</code></pre><p>接口定义文件具体支持的类型与结构，请参考官网  <a href="http://thrift.apache.org/docs/idl/" target="_blank" rel="noopener">Thrift interface description language</a>。</p>
<p>生成UserProfile.java 文件类似Protobuf 生成的对象文件。</p>
<pre><code>public class UserProfile implements org.apache.thrift.TBase&lt;UserProfile, UserProfile._Fields&gt;, java.io.Serializable, Cloneable {
  private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct(&quot;UserProfile&quot;);

  private static final org.apache.thrift.protocol.TField UID_FIELD_DESC = new org.apache.thrift.protocol.TField(&quot;uid&quot;, org.apache.thrift.protocol.TType.I32, (short)1);
  private static final org.apache.thrift.protocol.TField NAME_FIELD_DESC = new org.apache.thrift.protocol.TField(&quot;name&quot;, org.apache.thrift.protocol.TType.STRING, (short)2);
  private static final org.apache.thrift.protocol.TField BLURB_FIELD_DESC = new org.apache.thrift.protocol.TField(&quot;blurb&quot;, org.apache.thrift.protocol.TType.STRING, (short)3);

  private static final Map&lt;Class&lt;? extends IScheme&gt;, SchemeFactory&gt; schemes = new HashMap&lt;Class&lt;? extends IScheme&gt;, SchemeFactory&gt;();
  static {
    schemes.put(StandardScheme.class, new UserProfileStandardSchemeFactory());
    schemes.put(TupleScheme.class, new UserProfileTupleSchemeFactory());
  }

  public int uid; // required
  public String name; // required
  public String blurb; // required

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements org.apache.thrift.TFieldIdEnum {
    UID((short)1, &quot;uid&quot;),
    NAME((short)2, &quot;name&quot;),
    BLURB((short)3, &quot;blurb&quot;);

    private static final Map&lt;String, _Fields&gt; byName = new HashMap&lt;String, _Fields&gt;();

    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }

    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 1: // UID
          return UID;
        case 2: // NAME
          return NAME;
        case 3: // BLURB
          return BLURB;
        default:
          return null;
      }
    }
    ...
</code></pre><p>生成的服务接口文件UserStorage：</p>
<p>######1. 第1部分是服务接口的定义：<br>    public class UserStorage {</p>
<pre><code>public interface Iface {

  public void store(UserProfile user) throws org.apache.thrift.TException;

  public UserProfile retrieve(int uid) throws org.apache.thrift.TException;

}

public interface AsyncIface {

  public void store(UserProfile user, org.apache.thrift.async.AsyncMethodCallback&lt;AsyncClient.store_call&gt; resultHandler) throws org.apache.thrift.TException;

  public void retrieve(int uid, org.apache.thrift.async.AsyncMethodCallback&lt;AsyncClient.retrieve_call&gt; resultHandler) throws org.apache.thrift.TException;

}
</code></pre><p>######2. 第2部分同步和异步接口的Client实现：<br>    public static class Client extends org.apache.thrift.TServiceClient implements Iface {<br>        public static class Factory implements org.apache.thrift.TServiceClientFactory<client> {<br>          public Factory() {}<br>          public Client getClient(org.apache.thrift.protocol.TProtocol prot) {<br>            return new Client(prot);<br>          }<br>          public Client getClient(org.apache.thrift.protocol.TProtocol iprot, org.apache.thrift.protocol.TProtocol oprot) {<br>            return new Client(iprot, oprot);<br>          }<br>        }<br>        ….</client></p>
<pre><code>public static class AsyncClient extends org.apache.thrift.async.TAsyncClient implements AsyncIface {
  public static class Factory implements org.apache.thrift.async.TAsyncClientFactory&lt;AsyncClient&gt; {
    private org.apache.thrift.async.TAsyncClientManager clientManager;
    private org.apache.thrift.protocol.TProtocolFactory protocolFactory;
    public Factory(org.apache.thrift.async.TAsyncClientManager clientManager, org.apache.thrift.protocol.TProtocolFactory protocolFactory) {
      this.clientManager = clientManager;
      this.protocolFactory = protocolFactory;
    }
    public AsyncClient getAsyncClient(org.apache.thrift.transport.TNonblockingTransport transport) {
      return new AsyncClient(protocolFactory, clientManager, transport);
    }
  }
</code></pre><p>######3. 第3部分就是生成Processor：</p>
<pre><code>public static class Processor&lt;I extends Iface&gt; extends org.apache.thrift.TBaseProcessor&lt;I&gt; implements org.apache.thrift.TProcessor {
  private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class.getName());
  public Processor(I iface) {
    super(iface, getProcessMap(new HashMap&lt;String, org.apache.thrift.ProcessFunction&lt;I, ? extends org.apache.thrift.TBase&gt;&gt;()));
  }

  protected Processor(I iface, Map&lt;String,  org.apache.thrift.ProcessFunction&lt;I, ? extends  org.apache.thrift.TBase&gt;&gt; processMap) {
    super(iface, getProcessMap(processMap));
  }
</code></pre><p>可以看到Processor需要传入Iface接口的实现作为构造函数的参数，并且继承于TBaseProcessor类。</p>
<pre><code>private static &lt;I extends Iface&gt; Map&lt;String,  org.apache.thrift.ProcessFunction&lt;I, ? extends  org.apache.thrift.TBase&gt;&gt; getProcessMap(Map&lt;String,  org.apache.thrift.ProcessFunction&lt;I, ? extends  org.apache.thrift.TBase&gt;&gt; processMap) {
  processMap.put(&quot;store&quot;, new store());
  processMap.put(&quot;retrieve&quot;, new retrieve());
  return processMap;
}
</code></pre><p>这里的processMap就是具体的业务方法对象，每个业务方法都是一个ProcessFunction对象，会被TBaseProcessor中被调用。TBaseProcessor是所有生成的所有Processor 的父类。<br>在TBaseProcessor中，我们可以看到Processor的处理流程。</p>
<pre><code>@Override
public boolean process(TProtocol in, TProtocol out) throws TException {
  TMessage msg = in.readMessageBegin();
  // 根据msg.name 获取相应的ProcessFunction
  ProcessFunction fn = processMap.get(msg.name);
  if (fn == null) {
    TProtocolUtil.skip(in, TType.STRUCT);
    in.readMessageEnd();
    TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, &quot;Invalid method name: &apos;&quot;+msg.name+&quot;&apos;&quot;);
    out.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
    x.write(out);
    out.writeMessageEnd();
    out.getTransport().flush();
    return true;
  }
  fn.process(msg.seqid, in, out, iface);
  return true;
}
</code></pre><h4 id="四、实现完整的示例（服务端和客户端均采用阻塞IO传输的Transport）"><a href="#四、实现完整的示例（服务端和客户端均采用阻塞IO传输的Transport）" class="headerlink" title="四、实现完整的示例（服务端和客户端均采用阻塞IO传输的Transport）"></a>四、实现完整的示例（服务端和客户端均采用阻塞IO传输的Transport）</h4><h6 id="服务实现类"><a href="#服务实现类" class="headerlink" title="服务实现类"></a>服务实现类</h6><pre><code>public class UserStorageServiceImpl implements Iface{

    private static Map&lt;Integer, UserProfile&gt; userMap = new HashMap&lt;Integer, UserProfile&gt;();

    @Override
    public void store(UserProfile user) throws TException {
        userMap.put(user.getUid(), user);
    }

    @Override
    public UserProfile retrieve(int uid) throws TException {
        return userMap.get(uid);
    }

}
</code></pre><h6 id="创建一个阻塞式（Blocking）Socket的多线程的Server"><a href="#创建一个阻塞式（Blocking）Socket的多线程的Server" class="headerlink" title="创建一个阻塞式（Blocking）Socket的多线程的Server"></a>创建一个阻塞式（Blocking）Socket的多线程的Server</h6><pre><code>public class SyncUserStorageServer {

    public static void main(String[] args) throws TTransportException {
        int port = 8600;

        TServerSocket serverTransport = new TServerSocket(port);
        Factory portFactory = new TBinaryProtocol.Factory(true, true);
        TProcessor processor = new UserStorage.Processor&lt;UserStorageServiceImpl&gt;(new UserStorageServiceImpl());

        TThreadPoolServer.Args serverArgs = new TThreadPoolServer.Args(serverTransport);
        serverArgs.processor(processor);
        serverArgs.protocolFactory(portFactory);

        TThreadPoolServer server = new TThreadPoolServer(serverArgs);
        server.serve();
    }

}
</code></pre><h6 id="客户端的同步调用代码"><a href="#客户端的同步调用代码" class="headerlink" title="客户端的同步调用代码"></a>客户端的同步调用代码</h6><pre><code>public class UserStorageClient {

    public static void main(String[] args) throws TException, IOException {

        TTransport transport = new TSocket(&quot;localhost&quot;, 8600);
        TBinaryProtocol binaryProtocol = new TBinaryProtocol(transport);
        UserStorage.Client client = new UserStorage.Client.Factory().getClient(binaryProtocol);

        UserProfile user = new UserProfile(1, &quot;user_name&quot;, &quot;sth... i don&apos;t know&quot;);

        transport.open();

        System.out.println(user);
        client.store(user);
        System.out.println(&quot;store finished.&quot;);

        UserProfile fetchUser = client.retrieve(user.getUid());
        System.out.println(fetchUser);
        System.out.println(user.equals(fetchUser));

        transport.close();

    }
}
</code></pre><h4 id="五、服务端采用非阻塞式（Non-Blocking）传输的transport"><a href="#五、服务端采用非阻塞式（Non-Blocking）传输的transport" class="headerlink" title="五、服务端采用非阻塞式（Non-Blocking）传输的transport"></a>五、服务端采用非阻塞式（Non-Blocking）传输的transport</h4><p>######服务端</p>
<pre><code>public class AsyncUserStorageServer {

    public static void main(String[] args) throws TTransportException {
        int port = 8600;

        TNonblockingServerSocket serverTransport = new TNonblockingServerSocket(port);
        Factory portFactory = new TBinaryProtocol.Factory(true, true);
        TProcessor processor = new UserStorage.Processor&lt;UserStorageServiceImpl&gt;(new UserStorageServiceImpl());

        TThreadedSelectorServer.Args serverArgs = new TThreadedSelectorServer.Args(serverTransport);
        serverArgs.processor(processor);
        serverArgs.protocolFactory(portFactory);

        TThreadedSelectorServer server = new TThreadedSelectorServer(serverArgs);
        server.serve();
    }
}
</code></pre><h6 id="异步调用的客户端-异步调用必须采用非阻塞式传输TNonblockingTransport"><a href="#异步调用的客户端-异步调用必须采用非阻塞式传输TNonblockingTransport" class="headerlink" title="异步调用的客户端(异步调用必须采用非阻塞式传输TNonblockingTransport)"></a>异步调用的客户端(异步调用必须采用非阻塞式传输TNonblockingTransport)</h6><pre><code>public class AsyncUserStorageClient {


    static final CountDownLatch countDownLatch = new CountDownLatch(1);

    public static void main(String[] args) throws TException, IOException, InterruptedException {


        TNonblockingTransport transport = new TNonblockingSocket(&quot;localhost&quot;, 8600);
        TAsyncClientManager clientManager = new TAsyncClientManager();

        TProtocolFactory protocolFactory = new TBinaryProtocol.Factory();
        final UserStorage.AsyncClient client = new UserStorage.AsyncClient.Factory(clientManager, protocolFactory)
                                        .getAsyncClient(transport);

        final UserProfile user = new UserProfile(1, &quot;user_name&quot;, &quot;sth... i don&apos;t know&quot;);

        System.out.println(user);
        client.store(user, new AsyncMethodCallback&lt;UserStorage.AsyncClient.store_call&gt;() {

            @Override
            public void onError(Exception exception) {
                System.out.println(exception.getMessage());

                countDownLatch.countDown();
            }

            @Override
            public void onComplete(store_call response) {
                // TODO Auto-generated method stub
                try {
                    System.out.println(&quot;store finished.&quot;);
                    step2(client, user);
                } catch (TException e) {
                    e.printStackTrace();
                }
            }
        });


        countDownLatch.await();

    }

    private static void step2(UserStorage.AsyncClient client, final UserProfile user) throws TException {

        client.retrieve(user.getUid(), new AsyncMethodCallback&lt;UserStorage.AsyncClient.retrieve_call&gt;() {

            @Override
            public void onError(Exception exception) {
                // TODO Auto-generated method stub
                countDownLatch.countDown();
            }

            @Override
            public void onComplete(retrieve_call response) {
                try {
                    UserProfile fetchUser = response.getResult();
                    System.out.println(fetchUser);
                    System.out.println(user.equals(fetchUser));
                } catch (TException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }

                countDownLatch.countDown();

            }
        });
    }
</code></pre><h6 id="同步调用，但采用带缓存的网络IO（TFramedTransport）的客户端"><a href="#同步调用，但采用带缓存的网络IO（TFramedTransport）的客户端" class="headerlink" title="同步调用，但采用带缓存的网络IO（TFramedTransport）的客户端"></a>同步调用，但采用带缓存的网络IO（TFramedTransport）的客户端</h6><pre><code>public class SyncUserStorageClientForAsyncServer {

    public static void main(String[] args) throws TException, IOException {

        TTransport transport = new TFramedTransport(new TSocket(&quot;localhost&quot;, 8600));
        TBinaryProtocol binaryProtocol = new TBinaryProtocol(transport);
        UserStorage.Client client = new UserStorage.Client.Factory().getClient(binaryProtocol);

        transport.open();

        UserProfile user = new UserProfile(1, &quot;user_name&quot;, &quot;sth... i don&apos;t know&quot;);
        System.out.println(user);
        client.store(user);
        System.out.println(&quot;store finished.&quot;);

        UserProfile fetchUser = client.retrieve(user.getUid());
        System.out.println(fetchUser);
        System.out.println(user.equals(fetchUser));

        transport.close();
    }

}
</code></pre><h4 id="六、服务端采用带缓存的TFramedTransport传输"><a href="#六、服务端采用带缓存的TFramedTransport传输" class="headerlink" title="六、服务端采用带缓存的TFramedTransport传输"></a>六、服务端采用带缓存的TFramedTransport传输</h4><pre><code>public class FramedUserStorageServer {

    public static void main(String[] args) throws TTransportException {
        int port = 8600;

        TServerTransport serverTransport = new TServerSocket(port);
        Factory portFactory = new TBinaryProtocol.Factory(true, true);
        TProcessor processor = new UserStorage.Processor&lt;UserStorageServiceImpl&gt;(new UserStorageServiceImpl());

        TThreadPoolServer.Args serverArgs = new TThreadPoolServer.Args(serverTransport);
        serverArgs.processor(processor);
        serverArgs.protocolFactory(portFactory);
        serverArgs.transportFactory(new TFramedTransport.Factory());

        TThreadPoolServer server = new TThreadPoolServer(serverArgs);
        server.serve();
    }

}
</code></pre><h6 id="相应的同步调用客户"><a href="#相应的同步调用客户" class="headerlink" title="相应的同步调用客户"></a>相应的同步调用客户</h6><pre><code>public class SyncUserStorageClientForAsyncServer {

    public static void main(String[] args) throws TException, IOException {

        TTransport transport = new TFramedTransport(new TSocket(&quot;localhost&quot;, 8600));
        TBinaryProtocol binaryProtocol = new TBinaryProtocol(transport);
        UserStorage.Client client = new UserStorage.Client.Factory().getClient(binaryProtocol);

        transport.open();

        UserProfile user = new UserProfile(1, &quot;user_name&quot;, &quot;sth... i don&apos;t know&quot;);
        System.out.println(user);
        client.store(user);
        System.out.println(&quot;store finished.&quot;);

        UserProfile fetchUser = client.retrieve(user.getUid());
        System.out.println(fetchUser);
        System.out.println(user.equals(fetchUser));

        transport.close();
    }

}
</code></pre><h6 id="可以支持异步调用的客户端。"><a href="#可以支持异步调用的客户端。" class="headerlink" title="可以支持异步调用的客户端。"></a>可以支持异步调用的客户端。</h6><p>小结：服务端网络传输有三种模式：BLOCKING, FRAMED, NONBLOCKING;服务端与客户端采用的transport 与协议要一致；客户端是否异步调用与服务端是否异步网络IO无关。</p>
<p>例子源码： <a href="https://github.com/sharewind/thrift-quick-start" target="_blank" rel="noopener">https://github.com/sharewind/thrift-quick-start</a></p>
<p>参考资料</p>
<ul>
<li>thrift官方站点 <a href="http://thrift.apache.org/" target="_blank" rel="noopener">http://thrift.apache.org/</a></li>
<li>Apache Thrift Features <a href="http://thrift.apache.org/docs/features/" target="_blank" rel="noopener">http://thrift.apache.org/docs/features/</a></li>
<li>thrift 安装指南 <a href="http://thrift.apache.org/docs/install/" target="_blank" rel="noopener">Installation Tutorials</a></li>
<li>Apache Thrift (<strong>一篇详细介绍thrift的文章</strong>) <a href="http://jnb.ociweb.com/jnb/jnbJun2009.html" target="_blank" rel="noopener">http://jnb.ociweb.com/jnb/jnbJun2009.html</a></li>
<li>Apache Thrift入门1-架构&amp;介绍 <a href="http://www.javabloger.com/article/apache-thrift-architecture.html" target="_blank" rel="noopener">http://www.javabloger.com/article/apache-thrift-architecture.html</a></li>
<li>Apache Thrift - 可伸缩的跨语言服务开发框架 <a href="http://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/index.html" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/index.html</a></li>
<li>Java版的各种Thrift server实现的比较 <a href="http://www.codelast.com/?p=4824" target="_blank" rel="noopener">http://www.codelast.com/?p=4824</a></li>
<li>twitter开源的ThriftConnectionFactory <a href="https://github.com/twitter/commons/blob/master/src/java/com/twitter/common/thrift/ThriftConnectionFactory.java" target="_blank" rel="noopener">https://github.com/twitter/commons/blob/master/src/java/com/twitter/common/thrift/ThriftConnectionFactory.java</a></li>
<li>Thrift and Protocol Buffers performance in Java <a href="http://timyang.net/programming/thrift-protocol-buffers-performance-java/" target="_blank" rel="noopener">http://timyang.net/programming/thrift-protocol-buffers-performance-java/</a></li>
<li>Java 跨语言实现方案 <a href="http://rdc.taobao.com/team/jm/archives/389" target="_blank" rel="noopener">http://rdc.taobao.com/team/jm/archives/389</a></li>
</ul>

      
    </div>
    <footer class="article-footer2">
      <div id="footer-info" class="inner">
        <a href="http://www.618shoe.com/">莆田1:1精仿鞋微信号</a>
        <a href="http://www.618shoe.com/">莆田高仿鞋子的价格表</a>
        <a href="http://www.618shoe.com/">关于莆田仿鞋</a>
        <a href="http://www.618shoe.com/">莆田高仿鞋淘宝店店名</a>
        <a href="http://www.618shoe.com/">莆田精仿鞋官网</a>
         咨询QQ：<a title="点击这里给我发消息" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2727291807&amp;site=www.cactussoft.cn&amp;menu=yes" target="_blank"><img src="http://wpa.qq.com/pa?p=2:2727291807:41"></a>
      </div>
        <div id="footer-info" class="inner">
          <a href="http://www.618shoe.com/">莆田高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">1：1高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">高仿鞋批发市场</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">高仿鞋网</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">广州高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">外贸尾单鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">精仿鞋专线</a>&nbsp;&nbsp;
      </div>
      <div id="footer-info" class="inner">
             <a href="http://www.618shoe.com/">莆田高仿鞋批发</a>&nbsp;&nbsp;
             公司网站:&nbsp;&nbsp;<a href="http://www.618shoe.com//" target="_blank">http://www.618shoe.com/</a>&nbsp;&nbsp;
             <a href="http://www.618shoe.com/">高仿鞋批发市场</a>
             微信 <img src="/pics/qrcode.jpg" style="width:100px;height:100px;">
      </div>
    </footer>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2012/12/07/thrift-quick-start/" data-id="cja9pxgee000okk5ize61cn5f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2012/12/08/java-reflection/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Java 反射
        
      </div>
    </a>
  
  
    <a href="/2012/12/06/mongodb-indexes/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">MongoDB的复合索引</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/">Architecture</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DevTools/">DevTools</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DevTools-Eclipse/">DevTools Eclipse</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-Btrace/">Java Btrace</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-JVM/">Java JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-MultiThreading/">Java MultiThreading</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-NIO/">Java NIO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-Reflection/">Java Reflection</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-Unicode/">Java Unicode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Shell/">Linux Shell</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MongoDB/">MongoDB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/NSQ-golang/">NSQ golang</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Solr/">Solr</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Solr-Lucene/">Solr Lucene</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Unicode-Python/">Unicode Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git-DevTools/">git DevTools</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/jafka-zookeeper/">jafka zookeeper</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/jsonp-security/">jsonp security</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/thrift/">thrift</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/zookeeper/">zookeeper</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">February 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">August 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">July 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/03/">March 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12/">December 2012</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/11/21/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2015/01/16/process-task-by-queue/">process task by queue</a>
          </li>
        
          <li>
            <a href="/2015/01/15/threadpoolexecutor/">ThreadPoolExecutor 学习笔记</a>
          </li>
        
          <li>
            <a href="/2014/02/19/nsq-internals/">nsq internals</a>
          </li>
        
          <li>
            <a href="/2014/02/18/nsq-design/">nsq design</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
 	<div id="footer-info" class="inner">
     咨询QQ：<a title="点击这里给我发消息" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2727291807&amp;site=www.cactussoft.cn&amp;menu=yes" target="_blank"><img src="http://wpa.qq.com/pa?p=2:2727291807:41"></a>
 	</div>
   	<div id="footer-info" class="inner">
     	<a href="http://www.618shoe.com/">莆田高仿鞋批发</a>&nbsp;&nbsp;
     	<a href="http://www.618shoe.com/">1：1高仿鞋批发</a>&nbsp;&nbsp;
     	<a href="http://www.618shoe.com/">高仿鞋批发市场</a>&nbsp;&nbsp;
     	<a href="http://www.618shoe.com/">高仿鞋网</a>&nbsp;&nbsp;
     	<a href="http://www.618shoe.com/">广州高仿鞋批发</a>&nbsp;&nbsp;
    	<a href="http://www.618shoe.com/">外贸尾单鞋批发</a>&nbsp;&nbsp;
    	<a href="http://www.618shoe.com/">精仿鞋专线</a>&nbsp;&nbsp;
	</div>
 	<div id="footer-info" class="inner">
         <a href="http://www.618shoe.com/">莆田高仿鞋批发微信号</a>&nbsp;&nbsp;
         公司网站:&nbsp;&nbsp;<a href="http://www.618shoe.com//" target="_blank">http://www.618shoe.com/</a>&nbsp;&nbsp;
         <a href="http://www.618shoe.com/">高仿鞋批发市场</a>
         微信 <img src="/pics/qrcode.jpg" style="width:100px;height:100px;">
 	</div>
    <div id="footer-info" class="inner">
      &copy; 2017 Sharewind<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>