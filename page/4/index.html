<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="keywords" content=" 耐克赤足系列 耐克赤足2.0 3.0 4.0 5.0 7.0 耐克赤足跑鞋 耐克赤足二代 耐克编织跑鞋 耐克飞线系列 耐克飞线彩虹 耐克飞线气垫      耐克飞线价格 耐克飞线2014 耐克飞线鞋 耐克飞线登月 耐克飞线科技 耐克飞线2015 耐克登月系列 耐克登月3 4 5 6耐克登月系列跑步鞋 耐克阿甘鞋 耐克2013气垫鞋        耐克2014全掌气垫鞋 耐克2015气垫鞋 耐克max90高板反毛皮跑鞋" />
  <meta name="description" content="莆田批发高仿真标耐克系列跑鞋 耐克赤足滴塑新科技超轻NIKE FREE 5.0 耐克Nike Roshe Flyknit新款跑鞋 耐克2013磨砂皮            耐克赤足Nike Free 4.0 Flyknit赤足跑鞋 耐克登月6跑鞋 耐克2013男鞋 Nike Solarsoft Moccasin Woven 编织纹 超轻跑步鞋太阳神反毛皮 耐克2014飞线 耐克2015飞线      耐克登月NIKE FLYKNIT LUNAR2+编织版  耐克2013 耐克20K6代 7代 耐克87代系列轻量跑鞋" />
  
  <title>sharewind coder blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="sharewind coder blog">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="sharewind coder blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="sharewind coder blog">
  
    <link rel="alternate" href="/atom.xml" title="sharewind coder blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">sharewind coder blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-unicode-in-java" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2012/12/19/unicode-in-java/" class="article-date">
  <time datetime="2012-12-19T03:29:00.000Z" itemprop="datePublished">2012-12-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java-Unicode/">Java Unicode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/12/19/unicode-in-java/">unicode in java</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>####1. <strong>Unicode</strong><br>Unicode（统一码、万国码、单一码、标准万国码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简化地方式来呈现和处理文字。</p>
<p>Unicode依随着通用字符集(UCS)的标准而发展。在表示一个Unicode的字符时，通常会用“U+”然后紧接着一组十六进制的数字来表示这一个字符。</p>
<p><strong>通用字符集</strong><br>通用字符集（Universal Character Set，UCS）是由ISO制定的ISO 10646（或称ISO/IEC 10646）标准所定义的标准字符集。</p>
<p><strong>编码方式</strong>   </p>
<p><strong>代码点（code point）</strong>是指与一个编码表中的某个字符对应的代码值。在Unicode标准中，代码点采用16进制书写，并加上前缀U+,例如U+0041就是字母A的代码点。</p>
<p>统一码的编码方式与ISO 10646的通用字符集概念相对应。目前实际应用的统一码版本对应于UCS-2，使用16位的编码空间。也就是每个字符占用2个字节。这样理论上一共最多可以表示216（即65536）个字符。</p>
<p>上述16位统一码字符构成<strong>基本多文种平面</strong>,编码范围从U+000 到 U+FFFF。  </p>
<p>最新（但未实际广泛使用）的统一码版本定义了<strong>16个辅助平面</strong>，两者合起来至少需要占据21位的编码空间，比3字节略少。但事实上辅助平面字符仍然占用4字节编码空间，与UCS-4保持一致。<br>辅助平面的编码范围从U+10000 到 U+10FFFF。</p>
<p><strong>Unicode实现方式</strong><br>Unicode的实现方式不同于编码方式。一个字符的Unicode编码是确定的。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式有所不同。Unicode的实现方式称为Unicode转换格式（Unicode Transformation Format，简称为UTF）</p>
<p>####2. <strong>UTF-8</strong><br>UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码（定长码），也是一种前缀码。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍与ASCII兼容，这使得原来处理ASCII字符的软件无须或只须做少部份修改，即可继续使用。因此，它逐渐成为电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。</p>
<p>UTF-8使用一至四个字节为每个字符编码：   </p>
<ul>
<li>128个US-ASCII字符只需一个字节编码（Unicode范围由U+0000至U+007F）。  </li>
<li>带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要二个字节编码（Unicode范围由U+0080至U+07FF）。  </li>
<li>其他基本多文种平面（BMP）中的字符（这包含了大部分常用字）使用三个字节编码。  </li>
<li>其他极少使用的Unicode 辅助平面的字符使用四字节编码。  </li>
</ul>
<p>对上述提及的第四种字符而言，UTF-8使用四个字节来编码似乎太耗费资源了。但UTF-8对所有常用的字符都可以用三个字节表示，而且它的另一种选择，<strong>UTF-16编码</strong>，对前述的第四种字符同样需要四个字节来编码，所以要决定UTF-8或UTF-16哪种编码比较有效率，还要视所使用的字符的分布范围而定。</p>
<p>####3. <strong>UTF-16</strong><br>UTF-16是Unicode字符集的一种转换方式，即把Unicode的码位转换为16比特长的码元串行，以用于数据存储或传递。UTF是”Unicode/UCS Transformation Format”的首字母缩写，即把Unicode字符转换为某种格式之意。</p>
<p>UTF-16描述<br>Unicode的码空间从U+0000到U+10FFFF，共有1,112,064个码位(code point)可用来映射字符. Unicode的码空间可以划分为17个平面(plane)，每个平面包含216(65,536)个码位。每个平面的码位可表示为从U+xx0000到U+xxFFFF, 其中xx表示十六进制值从00<sub>16</sub> 到10<sub>16</sub>，共计17个平面。  </p>
<p>第一个平面成为基本多文种平面（Basic Multilingual Plane, BMP），或称第零平面（Plane 0）。其他平面称为辅助平面(Supplementary Planes)。基本多语言平面内，从U+D800到U+DFFF之间的码位区段是永久保留不映射到字符，因此UTF-16利用保留下来的0xD800-0xDFFF区段的码位来对辅助平面的字符的码位进行编码。</p>
<p><strong>从U+0000至U+D7FF以及从U+E000至U+FFFF的码位</strong><br>第一个Unicode平面(码位从U+0000至U+FFFF)包含了最常用的字符。该平面被称为基本多语言平面，缩写为BMP. UTF-16与UCS-2编码这个范围内的码位为<strong>单个16比特长的码元</strong>，数值等价于对应的码位. BMP中的这些码位是仅有的码位可以在UCS-2被表示.</p>
<p><strong>从U+10000到U+10FFFF的码位</strong><br>辅助平面(Supplementary Planes)中的码位，在UTF-16中被编码为一对<strong>16比特长的码元(即32bit,4Bytes)</strong></p>
<p>####4. <strong>ASCII</strong><br>ASCII（发音： /ˈæski/ ASS-kee[1]，American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统。<br>ASCI至今为止共定义了128个字符；其中33个字符无法显示（这是以现今操作系统为依归，但在DOS模式下可显示出一些诸如笑脸、扑克牌花式等8-bit符号），且这33个字符多数都已是陈废的控制字符。控制字符的用途主要是用来操控已经处理过的文字。在33个字符之外的是95个可显示的字符，包含用键盘敲下空白键所产生的空白字符也算1个可显示字符（显示为空白）。</p>
<p>####<strong>5. ISO/IEC 8859-1</strong><br>ISO 8859-1，正式编号为ISO/IEC 8859-1:1998，又称Latin-1或“西欧语言”，是国际标准化组织内ISO/IEC 8859的第一个8位字符集。它以ASCII为基础，在空置的0xA0-0xFF的范围内，加入96个字母及符号，藉以供使用附加符号的拉丁字母语言使用。曾推出过 ISO 8859-1:1987 版。</p>
<p>#####6. Unicode in Java</p>
<p>char 数据类型（和 Character 对象封装的值）基于原始的 Unicode 规范，将字符定义为固定宽度的 16 位实体。</p>
<p>从 U+0000 到 U+FFFF 的字符集有时也称为<em>Basic Multilingual Plane (BMP)</em>。代码点大于 U+FFFF 的字符称为<em>增补字符</em>。Java 2 平台在 char 数组以及 String 和 StringBuffer 类中使用<strong>UTF-16</strong>表示形式。在这种表现形式中，增补字符表示为<strong>一对char</strong> 值，第一个值取自高代理项 范围，即 (\uD800-\uDBFF)，第二个值取自低代理项 范围，即 (\uDC00-\uDFFF)。 </p>
<p><strong>所以，char 值表示 Basic Multilingual Plane (BMP) 代码点，其中包括代理项代码点，或 UTF-16 编码的代码单元。</strong>int 值表示所有 Unicode 代码点，包括增补代码点。int 的 21 个低位（最低有效位）用于表示 Unicode 代码点，并且 11 个高位（最高有效位）必须为零。除非另有指定，否则与增补字符和代理项 char 值有关的行为如下： </p>
<ul>
<li><strong>只接受一个 char 值的方法无法支持增补字符。</strong>它们将代理项字符范围内的 char 值视为未定义字符。例如，Character.isLetter(‘\uD840’) 返回 false，即使是特定值，如果在字符串的后面跟着任何低代理项值，那么它将表示一个字母。 </li>
<li><strong>接受一个 int 值的方法支持所有 Unicode 字符，其中包括增补字符。</strong>例如，Character.isLetter(0x2F81A) 返回 true，因为代码点值表示一个字母（一个 CJK 象形文字）。 </li>
</ul>
<p>参考资料</p>
<ul>
<li>JDK</li>
<li><a href="http://zh.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener">Unicode</a> - Wiki</li>
<li><a href="http://zh.wikipedia.org/wiki/UTF-8" target="_blank" rel="noopener">UTF-8</a>- Wiki</li>
<li><a href="http://zh.wikipedia.org/wiki/UTF-16" target="_blank" rel="noopener">UTF-16</a>- Wiki</li>
<li><a href="http://zh.wikipedia.org/wiki/ISO/IEC_8859-1" target="_blank" rel="noopener">ISO/IEC 8859-1</a> - Wiki</li>
<li><a href="http://www.cnblogs.com/maxupeng/archive/2011/06/22/2087579.html" target="_blank" rel="noopener">JAVA中的UTF-16编码</a></li>
</ul>

      
    </div>
    <footer class="article-footer2">
      <div id="footer-info" class="inner">
        <a href="http://www.618shoe.com/">莆田1:1精仿鞋微信号</a>
        <a href="http://www.618shoe.com/">莆田高仿鞋子的价格表</a>
        <a href="http://www.618shoe.com/">关于莆田仿鞋</a>
        <a href="http://www.618shoe.com/">莆田高仿鞋淘宝店店名</a>
        <a href="http://www.618shoe.com/">莆田精仿鞋官网</a>
         咨询QQ：<a title="点击这里给我发消息" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2727291807&amp;site=www.cactussoft.cn&amp;menu=yes" target="_blank"><img src="http://wpa.qq.com/pa?p=2:2727291807:41"></a>
      </div>
        <div id="footer-info" class="inner">
          <a href="http://www.618shoe.com/">莆田高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">1：1高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">高仿鞋批发市场</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">高仿鞋网</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">广州高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">外贸尾单鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">精仿鞋专线</a>&nbsp;&nbsp;
      </div>
      <div id="footer-info" class="inner">
             <a href="http://www.618shoe.com/">莆田高仿鞋批发</a>&nbsp;&nbsp;
             公司网站:&nbsp;&nbsp;<a href="http://www.618shoe.com//" target="_blank">http://www.618shoe.com/</a>&nbsp;&nbsp;
             <a href="http://www.618shoe.com/">高仿鞋批发市场</a>
             微信 <img src="/pics/qrcode.jpg" style="width:100px;height:100px;">
      </div>
    </footer>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2012/12/19/unicode-in-java/" data-id="cja9q2acj0016nh5icmg0sch6" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java-nio-selectors" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2012/12/19/java-nio-selectors/" class="article-date">
  <time datetime="2012-12-18T16:20:00.000Z" itemprop="datePublished">2012-12-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java-NIO/">Java NIO</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/12/19/java-nio-selectors/">Java NIO Selectors</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="一、Selector-基础"><a href="#一、Selector-基础" class="headerlink" title="一、Selector 基础"></a>一、Selector 基础</h4><p><strong>选择器（Selector）</strong><br>选择器管理着一个被注册通道集合的信息和它们的就绪状态。</p>
<p><strong>可选择的通道（SelectableChannel）</strong><br>这个抽象类提供了实现通道可选择性所需要的公共方法。它是所有支持就绪检查的通道类的父类。FileChannel是不可选择的，所有的socket通道都是可以选择的，包括从pipe对象中获取的。</p>
<p><strong>选择键(SelectionKey)</strong><br>选择键封装了特定的通道与特定的选择器的注册关系。通过调用 SelectableChannel.register() 注册方法会返回选择键。选择键包含了两个属性： interestOps 指示注册关系所关心的通过操作，readyOps 指示通道已经准备好的操作。</p>
<p>####选择器相关的类层次图<br><img src="/pics/java-nio-selectors-class.jpg" alt=""><br><a href="/pics/java-nio-selectors-class.jpg">点击查看大图</a></p>
<p><strong>SelectableChannel</strong>相关的API方法： </p>
<pre><code>public abstract class SelectableChannel extends AbstractInterruptibleChannel implements Channel{

    public final SelectionKey register(Selector sel, int ops)
    public abstract SelectionKey register(Selector sel, int ops, Object att) throws ClosedChannelException;

    public abstract boolean isRegistered();   
    public abstract SelectionKey keyFor(Selector sel); 

    public abstract SelectableChannel configureBlocking(boolean block)  throws IOException;
    public abstract boolean isBlocking();
    public abstract Object blockingLock();

    public abstract int validOps(); 
}
</code></pre><ul>
<li>在通道注册到选择器之前必须配置为非阻塞模式(通过调用 configureBlocking(false))  </li>
<li>通过调用validOps( )方法来获取特定的通道所支持的操作集合。  </li>
<li>一个单独的通道对象可以被注册到多个选择器上。可以调用isRegistered( )方法来检查一个通道是否被注册到任何一个选择器上。一个SelectionKey被取消后，并不会马上被注销（可能有时间延迟），所以isRegistered（）并不是确切答案。</li>
</ul>
<p><strong>Selector</strong>相关的API方法： </p>
<pre><code>public abstract class Selector implements Closeable {

    public static Selector open() throws IOException ;
    public abstract boolean isOpen();

    public abstract Set&lt;SelectionKey&gt; keys(); 
    public abstract Set&lt;SelectionKey&gt; selectedKeys();


    public abstract int selectNow() throws IOException; 
    public abstract int select(long timeout)throws IOException; 
    public abstract int select() throws IOException;

    public abstract Selector wakeup(); 
    public abstract void close() throws IOException;
}
</code></pre><p>SelectableChannel 尽管也定义了register方法，但最终都是将Channel注册到 Selector 上。Selector 维护了一个需要监控的Channel 集合。register 方法会返回一个建立了两个对象关联的SelctionKey。一个给定的Channel可以被注册到多个Selector上，而且不需要知道它被注册到哪个Selector上。</p>
<p><strong>AbstractSelectableChannel</strong>中register方法的实现:  </p>
<pre><code>public final SelectionKey register(Selector sel, int ops, Object att) throws ClosedChannelException {
    if (!isOpen())
        throw new ClosedChannelException();
    if ((ops &amp; ~validOps()) != 0)
        throw new IllegalArgumentException();
    synchronized (regLock) {
        if (blocking)
            throw new IllegalBlockingModeException();

        // 查找已注册到selector 上的SelectionKey,如果有则对原有的Key进行更新
        SelectionKey k = findKey(sel);
        if (k != null) {
            k.interestOps(ops);
            k.attach(att);
        }
        if (k == null) {
            // New registration // 调用了AbstractSelector的register方法
            k = ((AbstractSelector)sel).register(this, ops, att);
            addKey(k);
        }
        return k;
    }
}
</code></pre><p><strong>AbstractSelector</strong>的register方法定义</p>
<pre><code>protected abstract SelectionKey register(AbstractSelectableChannel ch,
                                         int ops, Object att);
</code></pre><p><strong>SelectionKey</strong>的主要API：  </p>
<pre><code>public abstract class SelectionKey {

    public static final int OP_READ = 1 &lt;&lt; 0;
    public static final int OP_WRITE = 1 &lt;&lt; 2;
    public static final int OP_CONNECT = 1 &lt;&lt; 3;
    public static final int OP_ACCEPT = 1 &lt;&lt; 4;

    public abstract SelectableChannel channel();
    public abstract Selector selector();

    public abstract boolean isValid();
    public abstract void cancel();

    public abstract int interestOps();
    public abstract SelectionKey interestOps(int ops);
    public abstract int readyOps();

    public final boolean isReadable(){
        return (readyOps() &amp; OP_READ) != 0;
    }
    public final boolean isWritable()
    public final boolean isConnectable()
    public final boolean isAcceptable()

    public final Object attach(Object ob)
    public final Object attachment()
}
</code></pre><p><strong>SelectionKey</strong><br>每次向选择器注册通道时就会创建一个选择键。通过调用某个键的 cancel 方法、关闭其通道，或者通过关闭其选择器来取消 该键之前，它一直保持有效。取消某个键不会立即从其选择器中移除它；相反，会将该键添加到选择器的已取消键集，以便在下一次进行选择操作时移除它。可通过调用某个键的 isValid 方法来测试其有效性。 </p>
<p>#####1. <strong>AbstractSelectionKey</strong>中<strong>cancel()</strong>方法的实现 </p>
<pre><code>public final void cancel() {
    // Synchronizing &quot;this&quot; to prevent this key from getting canceled
    // multiple times by different threads, which might cause race
    // condition between selector&apos;s select() and channel&apos;s close().
    synchronized (this) {
        if (valid) {
            valid = false;
            ((AbstractSelector)selector()).cancel(this);
        }
    }
}
</code></pre><p>#####2. <strong>AbstractSelector</strong>中<strong>cancel()</strong>方法的实现 </p>
<pre><code>void cancel(SelectionKey k) {                       // package-private
    synchronized (cancelledKeys) {
        cancelledKeys.add(k);
    }
}
</code></pre><p>#####3. <strong>SelectorImpl</strong>中的select方法</p>
<pre><code>public int select(long timeout)throws IOException{
    if (timeout &lt; 0)
        throw new IllegalArgumentException(&quot;Negative timeout&quot;);
    return lockAndDoSelect((timeout == 0) ? -1 : timeout);
}

public int select() throws IOException {
    return select(0);
}

private int lockAndDoSelect(long timeout) throws IOException {
    synchronized (this) {
        if (!isOpen())
            throw new ClosedSelectorException();
        synchronized (publicKeys) {
            synchronized (publicSelectedKeys) {
                // 调用 doSelect 抽象方法
                return doSelect(timeout);
            }
        }
    }
}
</code></pre><p>#####4. Windows平台Selector的实现类<strong>WindowsSelectorImpl</strong>中的doSelect方法</p>
<pre><code>protected int doSelect(long timeout) throws IOException {
    if (channelArray == null)
        throw new ClosedSelectorException();
    this.timeout = timeout; // set selector timeout

    // 处理取消注册队列,位于 SelectorImpl.processDeregisterQueue()
    processDeregisterQueue();
    if (interruptTriggered) {
        resetWakeupSocket();
        return 0;
    }
    .... 
    processDeregisterQueue();// select结束时，再执行一次取消注册的方法
</code></pre><p>#####5.<strong>SelectorImpl.processDeregisterQueue()</strong></p>
<pre><code>void processDeregisterQueue() throws IOException {
    // Precondition: Synchronized on this, keys, and selectedKeys
    Set cks = cancelledKeys();
    // 获取所有取消的selectionKey，遍历进行移除操作
    synchronized (cks) {
        if (!cks.isEmpty()) {
            Iterator i = cks.iterator();
            while (i.hasNext()) {
                SelectionKeyImpl ski = (SelectionKeyImpl)i.next();
                try {
                    implDereg(ski);
                } catch (SocketException se) {
                    IOException ioe = new IOException(
                        &quot;Error deregistering key&quot;);
                    ioe.initCause(se);
                    throw ioe;
                } finally {
                    i.remove();
                }
            }
        }
    }
}
</code></pre><p><strong>建立选择器</strong></p>
<pre><code>Selector selector = Selector.open();
channel1.register(selector,SelectionKey.OP_READ);
channel2.register(selector,SelectionKey.OP_WRITE);
channel3.register(selector,SelectionKey.OP_READ| OP_WRITE);
readyCount = selector.select(10000);
</code></pre><p>select()方法将线程置于休眠状态，直到感兴趣的操作中一个发生或10秒钟时间过去。<br>Selector中的open方法，通过SelectorProvider.openSelector()来创建Selector实例：</p>
<pre><code>public static Selector open() throws IOException {
    return SelectorProvider.provider().openSelector();
}
</code></pre><p>当不再需要Selector 时，可以调用 close()方法来释放它可能占用的资源，并将所有相关的SelectionKey设置为无效。</p>
<p><strong>SelectionKey</strong></p>
<p>SelectionKey表示注册关系，可以调用 cancel方法取消注册；也可以调用 isValid()来判断是否有效。<br>当键被取消时，它将被放在相关的选择器的已取消的键的集合里。注册不会立即被取消，但键会立即失效（参见4.3节）。当再次调用select( )方法时（或者一个正在进行的select()调用结束时），已取消的键的集合中的被取消的键将被清理掉，并且相应的注销也将完成。</p>
<p>当通道关闭时，所有相关的键会自动取消（记住，一个通道可以被注册到多个选择器上）。当选择器关闭时，所有被注册到该选择器的通道都将被注销，并且相关的键将立即被无效化（取消）。一旦键被无效化，调用它的与选择相关的方法就将抛出CancelledKeyException。</p>
<p>可以通过调用键的readyOps( )方法来获取相关的通道的已经就绪的操作。ready集合是interest集合的子集，并且表示了interest集合中从上次调用select( )以来已经就绪的那些操作。</p>
<pre><code>if((key.readyOps() &amp; SelectionKey.OP_READ) != 0){
    buffer.clear();
    key.channel.ready(buffer);
    buffer.flip();
    // do sth..
}
</code></pre><p>需要注意的是，通过相关的选择键的readyOps( )方法返回的就绪状态指示只是一个提示，不是保证。</p>
<h4 id="二、使用Selector"><a href="#二、使用Selector" class="headerlink" title="二、使用Selector"></a>二、使用Selector</h4><p><strong>三种选择键集</strong><br>通过 SelectionKey 对象来表示可选择通道到选择器的注册。选择器维护了三种选择键集：<br>● <strong>键集</strong> 包含的键表示当前通道到此选择器的注册。此集合由 keys 方法返回。<br>● <strong>已选择键集</strong> 是这样一种键的集合，即在前一次选择操作期间，检测每个键的通道是否已经至少为该键的相关操作集所标识的一个操作准备就绪。此集合由 selectedKeys 方法返回。已选择键集始终是键集的一个子集。<br>● <strong>已取消键集</strong> 是已被取消但其通道尚未注销的键的集合。不可直接访问此集合。已取消键集始终是键集的一个子集。 </p>
<p>在新创建的选择器中，这三个集合都是空集合。 </p>
<p>通过某个通道的 register 方法注册该通道时，所带来的副作用是向选择器的键集中添加了一个键。在选择操作期间从键集中移除已取消的键。键集本身是不可直接修改的。 </p>
<p>不管是通过关闭某个键的通道还是调用该键的 cancel 方法来取消键，该键都被添加到其选择器的已取消键集中。取消某个键会导致在下一次选择操作期间注销该键的通道，而在注销时将从所有选择器的键集中移除该键。 </p>
<p>通过选择操作将键添加到已选择键集中。可通过调用已选择键集的 remove 方法，或者通过调用从该键集获得的 iterator 的 remove 方法直接移除某个键。通过任何其他方式从不会将键从已选择键集中移除；特别是，它们不会因为影响选择操作而被移除。不能将键直接添加到已选择键集中。 </p>
<p><strong>选择</strong><br>在每次选择操作期间，都可以将键添加到选择器的已选择键集以及从中将其移除，并且可以从其键集和已取消键集中将其移除。选择是由 select()、select(long) 和 selectNow() 方法执行的，执行涉及三个步骤：   </p>
<ol>
<li><p>将已取消键集中的每个键从所有键集中移除（如果该键是键集的成员），并注销其通道。此步骤使已取消键集成为空集。 </p>
</li>
<li><p>在开始进行选择操作时，应查询基础操作系统来更新每个剩余通道的准备就绪信息，以执行由其键的相关集合所标识的任意操作。对于已为至少一个这样的操作准备就绪的通道，执行以下两种操作之一： </p>
<p> a. 如果该通道的键尚未在已选择键集中，则将其添加到该集合中，并修改其准备就绪操作集，以准确地标识那些通道现在已报告为之准备就绪的操作。丢弃准备就绪操作集中以前记录的所有准备就绪信息。 </p>
<p> b. 如果该通道的键已经在已选择键集中，则修改其准备就绪操作集，以准确地标识所有通道已报告为之准备就绪的新操作。保留准备就绪操作集以前记录的所有准备就绪信息；换句话说，基础系统所返回的准备就绪操作集是和该键的当前准备就绪操作集按位分开 (bitwise-disjoined) 的。 </p>
</li>
<li><p>如果在此步骤开始时键集中的所有键都有空的相关集合，则不会更新已选择键集和任意键的准备就绪操作集。<br>如果在步骤 (2) 的执行过程中要将任意键添加到已取消键集中，则处理过程如步骤 (1)。 </p>
</li>
</ol>
<p>是否阻塞选择操作以等待一个或多个通道准备就绪，如果这样做的话，要等待多久，这是三种选择方法之间的唯一本质差别。 </p>
<p><strong>并发性</strong><br>选择器自身可由多个并发线程安全使用，但是其键集并非如此。 </p>
<p>选择操作在选择器本身上、在键集上和在已选择键集上是同步的，顺序也与此顺序相同。在执行上面的步骤 (1) 和 (3) 时，它们在已取消键集上也是同步的。 </p>
<p>在执行选择操作的过程中，更改选择器键的相关集合对该操作没有影响；进行下一次选择操作才会看到此更改。 </p>
<p>可在任意时间取消键和关闭通道。因此，在一个或多个选择器的键集中出现某个键并不意味着该键是有效的，也不意味着其通道处于打开状态。如果存在另一个线程取消某个键或关闭某个通道的可能性，那么应用程序代码进行同步时应该小心，并且必要时应该检查这些条件。 </p>
<p>阻塞在 select() 或 select(long) 方法之一中的某个线程可能被其他线程以下列三种方式之一中断： </p>
<p>● 通过调用选择器的 wakeup 方法，<br>● 通过调用选择器的 close 方法，或者<br>● 在通过调用已阻塞线程的 interrupt 方法的情况下，将设置其中断状态并且将调用该选择器的 wakeup 方法。 </p>
<p>close 方法在选择器上是同步的，并且所有三个键集都与选择操作中的顺序相同。 </p>
<p>一般情况下，选择器的键和已选择键集由多个并发线程使用是不安全的。如果这样的线程可以直接修改这些键集之一，那么应该通过对该键集本身进行同步来控制访问。</p>
<p><strong>管理选择键</strong></p>
<p>通常的做法是在选择器上调用一次select操作(这将更新已选择的键的集合)，然后遍历selectKeys( )方法返回的键的集合。在按顺序进行检查每个键的过程中，相关的通道也根据键的就绪集合进行处理。然后键将从已选择的键的集合中被移除（通过在Iterator对象上调用remove( )方法），然后检查下一个键。完成后，通过再次调用select( )方法重复这个循环。</p>
<p>示例：</p>
<pre><code>public class SelectSockets {

    public static int port_number = 1234;

    public static void main(String[] args) throws IOException {
        new SelectSockets().start(args);
    }

    public void start(String[] args) throws IOException{
        int port = port_number;
        if(args.length &gt; 0){
            port = Integer.parseInt(args[0]);
        }

        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
        ServerSocket serverSocket = serverSocketChannel.socket();
        serverSocket.bind(new InetSocketAddress(port));
        serverSocketChannel.configureBlocking(false);

        Selector selector = Selector.open();
        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

        while(true){
            int n = selector.select();
            if(n == 0){
                continue;
            }

            Iterator&lt;SelectionKey&gt;  iter = selector.selectedKeys().iterator();
            while(iter.hasNext()){
                SelectionKey key = iter.next();
                if(key.isAcceptable()){

                    ServerSocketChannel server = (ServerSocketChannel)key.channel();
                    SocketChannel channel = server.accept();
                    registerChannel(selector,channel,SelectionKey.OP_READ);
                    sayHello(channel);
                }

                if(key.isReadable()){
                    readDataFromSocket(key);
                }
                iter.remove();
            }
        }
    }

    public ByteBuffer buffer = ByteBuffer.allocate(1024);

    private void readDataFromSocket(SelectionKey key) throws IOException {
        SocketChannel socketChannel = (SocketChannel) key.channel();
        int count;

        buffer.clear();
        while( (count =socketChannel.read(buffer)) &gt; 0){
            buffer.flip();

            while (buffer.hasRemaining()) {
                socketChannel.write(buffer);
            }
            buffer.clear();
        }

        if(count &lt; 0){
            socketChannel.close();
        }
    }

    private void sayHello(SocketChannel channel) throws IOException {
        buffer.clear();
        buffer.put(&quot;Hi here! \r\n&quot;.getBytes());
        buffer.flip();

        channel.write(buffer);
    }

    private void registerChannel(Selector selector, SocketChannel channel,int ops) throws IOException {
        if(channel == null){
            return;
        }
        channel.configureBlocking(false);
        channel.register(selector, ops);
    }

}
</code></pre><p>参考资料</p>
<ul>
<li>JDK</li>
<li>Java NIO</li>
<li><a href="http://tutorials.jenkov.com/java-nio/selectors.html" target="_blank" rel="noopener">Java NIO Selector</a> - 一篇很好的介绍selector的文章</li>
</ul>

      
    </div>
    <footer class="article-footer2">
      <div id="footer-info" class="inner">
        <a href="http://www.618shoe.com/">莆田1:1精仿鞋微信号</a>
        <a href="http://www.618shoe.com/">莆田高仿鞋子的价格表</a>
        <a href="http://www.618shoe.com/">关于莆田仿鞋</a>
        <a href="http://www.618shoe.com/">莆田高仿鞋淘宝店店名</a>
        <a href="http://www.618shoe.com/">莆田精仿鞋官网</a>
         咨询QQ：<a title="点击这里给我发消息" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2727291807&amp;site=www.cactussoft.cn&amp;menu=yes" target="_blank"><img src="http://wpa.qq.com/pa?p=2:2727291807:41"></a>
      </div>
        <div id="footer-info" class="inner">
          <a href="http://www.618shoe.com/">莆田高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">1：1高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">高仿鞋批发市场</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">高仿鞋网</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">广州高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">外贸尾单鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">精仿鞋专线</a>&nbsp;&nbsp;
      </div>
      <div id="footer-info" class="inner">
             <a href="http://www.618shoe.com/">莆田高仿鞋批发</a>&nbsp;&nbsp;
             公司网站:&nbsp;&nbsp;<a href="http://www.618shoe.com//" target="_blank">http://www.618shoe.com/</a>&nbsp;&nbsp;
             <a href="http://www.618shoe.com/">高仿鞋批发市场</a>
             微信 <img src="/pics/qrcode.jpg" style="width:100px;height:100px;">
      </div>
    </footer>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2012/12/19/java-nio-selectors/" data-id="cja9q2acl0019nh5i010tbgs7" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-thrift-src-study" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2012/12/18/thrift-src-study/" class="article-date">
  <time datetime="2012-12-18T13:26:00.000Z" itemprop="datePublished">2012-12-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/thrift/">thrift</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/12/18/thrift-src-study/">thrift src study</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight java"><figcaption><span>SelectAcceptThread-接收请求的线程</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectAcceptThread</span> <span class="keyword">extends</span> <span class="title">AbstractSelectThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// The server transport on which new client transports will be accepted</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> TNonblockingServerTransport serverTransport;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set up the thread that will handle the non-blocking accepts, reads, and</span></span><br><span class="line"><span class="comment">    * writes.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SelectAcceptThread</span><span class="params">(<span class="keyword">final</span> TNonblockingServerTransport serverTransport)</span></span></span><br><span class="line"><span class="function">   <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.serverTransport = serverTransport;</span><br><span class="line">     serverTransport.registerSelector(selector);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStopped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> stopped_;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The work loop. Handles both selecting (all IO operations) and managing</span></span><br><span class="line"><span class="comment">    * the selection preferences of all existing connections.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">while</span> (!stopped_) &#123;</span><br><span class="line">	  <span class="comment">// 这里执行select 方法</span></span><br><span class="line">         select();</span><br><span class="line">	  <span class="comment">// 处理NIO事件</span></span><br><span class="line">         processInterestChanges();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (SelectionKey selectionKey : selector.keys()) &#123;</span><br><span class="line">         cleanupSelectionKey(selectionKey);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">       LOGGER.error(<span class="string">"run() exiting due to uncaught error"</span>, t);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       stopped_ = <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span>SelectAcceptThread-select方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// wait for io events.</span></span><br><span class="line">       selector.select();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// process the io events we received</span></span><br><span class="line">       Iterator&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys().iterator();</span><br><span class="line">       <span class="keyword">while</span> (!stopped_ &amp;&amp; selectedKeys.hasNext()) &#123;</span><br><span class="line">         SelectionKey key = selectedKeys.next();</span><br><span class="line">         selectedKeys.remove();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// skip if not valid</span></span><br><span class="line">         <span class="keyword">if</span> (!key.isValid()) &#123;</span><br><span class="line">           cleanupSelectionKey(key);</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">// 分别处理感兴趣的事件</span></span><br><span class="line">         <span class="comment">// if the key is marked Accept, then it has to be the server</span></span><br><span class="line">         <span class="comment">// transport.</span></span><br><span class="line">         <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">           handleAccept();</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">           <span class="comment">// deal with reads</span></span><br><span class="line">           handleRead(key);</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">           <span class="comment">// deal with writes</span></span><br><span class="line">           handleWrite(key);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           LOGGER.warn(<span class="string">"Unexpected state in select! "</span> + key.interestOps());</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       LOGGER.warn(<span class="string">"Got an IOException while selecting!"</span>, e);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法会在后面的调用中被用到。。。</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Check to see if there are any FrameBuffers that have switched their</span></span><br><span class="line"><span class="comment">    * interest type from read to write or vice versa.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processInterestChanges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span> (selectInterestChanges) &#123;</span><br><span class="line">       <span class="keyword">for</span> (FrameBuffer fb : selectInterestChanges) &#123;</span><br><span class="line">         fb.changeSelectInterests();</span><br><span class="line">       &#125;</span><br><span class="line">       selectInterestChanges.clear();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span>SelectAcceptThread-接收一个新的连接</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Accept a new connection.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleAccept</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SelectionKey clientKey = <span class="keyword">null</span>;</span><br><span class="line">    TNonblockingTransport client = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// accept the connection</span></span><br><span class="line">      client = (TNonblockingTransport)serverTransport.accept();</span><br><span class="line">      clientKey = client.registerSelector(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次都新建一个FrameBuffer，</span></span><br><span class="line">      <span class="comment">// add this key to the map</span></span><br><span class="line">      FrameBuffer frameBuffer = <span class="keyword">new</span> FrameBuffer(client, clientKey,</span><br><span class="line">        SelectAcceptThread.<span class="keyword">this</span>);</span><br><span class="line">      clientKey.attach(frameBuffer);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TTransportException tte) &#123;</span><br><span class="line">      <span class="comment">// something went wrong accepting.</span></span><br><span class="line">      LOGGER.warn(<span class="string">"Exception trying to accept!"</span>, tte);</span><br><span class="line">      tte.printStackTrace();</span><br><span class="line">      <span class="keyword">if</span> (clientKey != <span class="keyword">null</span>) cleanupSelectionKey(clientKey);</span><br><span class="line">      <span class="keyword">if</span> (client != <span class="keyword">null</span>) client.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span>FrameBuffer的构造函数.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">FrameBuffer</span><span class="params">(<span class="keyword">final</span> TNonblockingTransport trans,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">final</span> SelectionKey selectionKey,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">final</span> AbstractSelectThread selectThread)</span> </span>&#123;</span><br><span class="line">     trans_ = trans;</span><br><span class="line">     selectionKey_ = selectionKey;</span><br><span class="line">     selectThread_ = selectThread;</span><br><span class="line">  <span class="comment">// 初始化的Buffer 为4个字节，用来读取FrameSize 的整数</span></span><br><span class="line">     buffer_ = ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Frame 的初始状态 </span></span><br><span class="line">   <span class="comment">// where in the process of reading/writing are we?</span></span><br><span class="line">   <span class="keyword">private</span> FrameBufferState state_ = FrameBufferState.READING_FRAME_SIZE;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span>SelectAcceptThread-handleRead.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Do the work required to read from a readable client. If the frame is</span></span><br><span class="line"><span class="comment">   * fully read, then invoke the method call.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleRead</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">    FrameBuffer buffer = (FrameBuffer) key.attachment();</span><br><span class="line">    <span class="keyword">if</span> (!buffer.read()) &#123;</span><br><span class="line"><span class="comment">// 如果读取失败，清理掉这个selection key </span></span><br><span class="line">      cleanupSelectionKey(key);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 如果整个frame已读取完成，开始调用具体的业务方法</span></span><br><span class="line">    <span class="comment">// if the buffer's frame read is complete, invoke the method.</span></span><br><span class="line">    <span class="keyword">if</span> (buffer.isFrameFullyRead()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!requestInvoke(buffer)) &#123;</span><br><span class="line">        cleanupSelectionKey(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Do connection-close cleanup on a given SelectionKey.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">cleanupSelectionKey</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// remove the records from the two maps</span></span><br><span class="line">    FrameBuffer buffer = (FrameBuffer) key.attachment();</span><br><span class="line">    <span class="keyword">if</span> (buffer != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// close the buffer</span></span><br><span class="line">      buffer.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cancel the selection key</span></span><br><span class="line">    key.cancel();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>#####read in FrameBuffer</p>
<figure class="highlight java"><figcaption><span>FrameBuffer-read方法.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (state_ == FrameBufferState.READING_FRAME_SIZE) &#123;</span><br><span class="line">       <span class="comment">// try to read the frame size completely</span></span><br><span class="line">       <span class="keyword">if</span> (!internalRead()) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// if the frame size has been read completely, then prepare to read the</span></span><br><span class="line">       <span class="comment">// actual frame.</span></span><br><span class="line">       <span class="keyword">if</span> (buffer_.remaining() == <span class="number">0</span>) &#123;</span><br><span class="line">	  <span class="comment">// 读取到帧大小</span></span><br><span class="line">         <span class="comment">// pull out the frame size as an integer.</span></span><br><span class="line">         <span class="keyword">int</span> frameSize = buffer_.getInt(<span class="number">0</span>);</span><br><span class="line">         <span class="keyword">if</span> (frameSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           LOGGER.error(<span class="string">"Read an invalid frame size of "</span> + frameSize</span><br><span class="line">               + <span class="string">". Are you using TFramedTransport on the client side?"</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// if this frame will always be too large for this server, log the</span></span><br><span class="line">         <span class="comment">// error and close the connection.</span></span><br><span class="line">         <span class="keyword">if</span> (frameSize &gt; MAX_READ_BUFFER_BYTES) &#123;</span><br><span class="line">           LOGGER.error(<span class="string">"Read a frame size of "</span> + frameSize</span><br><span class="line">               + <span class="string">", which is bigger than the maximum allowable buffer size for ALL connections."</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// if this frame will push us over the memory limit, then return.</span></span><br><span class="line">         <span class="comment">// with luck, more memory will free up the next time around.</span></span><br><span class="line">         <span class="keyword">if</span> (readBufferBytesAllocated.get() + frameSize &gt; MAX_READ_BUFFER_BYTES) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// increment the amount of memory allocated to read buffers</span></span><br><span class="line">         readBufferBytesAllocated.addAndGet(frameSize + <span class="number">4</span>);</span><br><span class="line">	</span><br><span class="line">	  <span class="comment">// 重新分配缓冲区大小</span></span><br><span class="line">         <span class="comment">// reallocate the readbuffer as a frame-sized buffer</span></span><br><span class="line">         buffer_ = ByteBuffer.allocate(frameSize + <span class="number">4</span>);</span><br><span class="line">         buffer_.putInt(frameSize);</span><br><span class="line"></span><br><span class="line">         state_ = FrameBufferState.READING_FRAME;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// this skips the check of READING_FRAME state below, since we can't</span></span><br><span class="line">         <span class="comment">// possibly go on to that state if there's data left to be read at</span></span><br><span class="line">         <span class="comment">// this one.</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// it is possible to fall through from the READING_FRAME_SIZE section</span></span><br><span class="line">     <span class="comment">// to READING_FRAME if there's already some frame data available once</span></span><br><span class="line">     <span class="comment">// READING_FRAME_SIZE is complete.</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (state_ == FrameBufferState.READING_FRAME) &#123;</span><br><span class="line">       <span class="keyword">if</span> (!internalRead()) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读完整个Frame,将当前interestOps 置为0</span></span><br><span class="line">       <span class="comment">// since we're already in the select loop here for sure, we can just</span></span><br><span class="line">       <span class="comment">// modify our selection key directly.</span></span><br><span class="line">       <span class="keyword">if</span> (buffer_.remaining() == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// get rid of the read select interests</span></span><br><span class="line">         selectionKey_.interestOps(<span class="number">0</span>);</span><br><span class="line">         state_ = FrameBufferState.READ_FRAME_COMPLETE;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// if we fall through to this point, then the state must be invalid.</span></span><br><span class="line">     LOGGER.error(<span class="string">"Read was called but state is invalid ("</span> + state_ + <span class="string">")"</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Check if this FrameBuffer has a full frame read.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFrameFullyRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> state_ == FrameBufferState.READ_FRAME_COMPLETE;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭网络连接</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Shut the connection down.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// if we're being closed due to an error, we might have allocated a</span></span><br><span class="line">     <span class="comment">// buffer that we need to subtract for our memory accounting.</span></span><br><span class="line">     <span class="keyword">if</span> (state_ == FrameBufferState.READING_FRAME || state_ == FrameBufferState.READ_FRAME_COMPLETE) &#123;</span><br><span class="line">       readBufferBytesAllocated.addAndGet(-buffer_.array().length);</span><br><span class="line">     &#125;</span><br><span class="line">     trans_.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>#####invoke in FrameBuffer </p>
<figure class="highlight java"><figcaption><span>FrameBuffer-invoke 进行实际调用.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Actually invoke the method signified by this FrameBuffer.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     TTransport inTrans = getInputTransport();</span><br><span class="line">     TProtocol inProt = inputProtocolFactory_.getProtocol(inTrans);</span><br><span class="line">     TProtocol outProt = outputProtocolFactory_.getProtocol(getOutputTransport());</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       processorFactory_.getProcessor(inTrans).process(inProt, outProt);</span><br><span class="line">	<span class="comment">// 准备输出 </span></span><br><span class="line">       responseReady();</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (TException te) &#123;</span><br><span class="line">       LOGGER.warn(<span class="string">"Exception while invoking!"</span>, te);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">       LOGGER.error(<span class="string">"Unexpected throwable while invoking!"</span>, t);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// This will only be reached when there is a throwable.</span></span><br><span class="line">     state_ = FrameBufferState.AWAITING_CLOSE;</span><br><span class="line">     requestSelectInterestChange();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出时放在byteArrayOutputStream 中</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> TTransport <span class="title">getOutputTransport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     response_ = <span class="keyword">new</span> TByteArrayOutputStream();</span><br><span class="line">     <span class="keyword">return</span> outputTransportFactory_.getTransport(<span class="keyword">new</span> TIOStreamTransport(response_));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">responseReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// the read buffer is definitely no longer in use, so we will decrement</span></span><br><span class="line">     <span class="comment">// our read buffer count. we do this here as well as in close because</span></span><br><span class="line">     <span class="comment">// we'd like to free this read memory up as quickly as possible for other</span></span><br><span class="line">     <span class="comment">// clients.</span></span><br><span class="line">     readBufferBytesAllocated.addAndGet(-buffer_.array().length);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有返回值的方法</span></span><br><span class="line">     <span class="keyword">if</span> (response_.len() == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">// 状态为等待注册为读取。。。</span></span><br><span class="line">       <span class="comment">// go straight to reading again. this was probably an oneway method</span></span><br><span class="line">       state_ = FrameBufferState.AWAITING_REGISTER_READ;</span><br><span class="line">       buffer_ = <span class="keyword">null</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 把response 放入buffer中，并更新状态为等待写入</span></span><br><span class="line">       buffer_ = ByteBuffer.wrap(response_.get(), <span class="number">0</span>, response_.len());</span><br><span class="line"></span><br><span class="line">       <span class="comment">// set state that we're waiting to be switched to write. we do this</span></span><br><span class="line">       <span class="comment">// asynchronously through requestSelectInterestChange() because there is</span></span><br><span class="line">       <span class="comment">// a possibility that we're not in the main thread, and thus currently</span></span><br><span class="line">       <span class="comment">// blocked in select(). (this functionality is in place for the sake of</span></span><br><span class="line">       <span class="comment">// the HsHa server.)</span></span><br><span class="line">       state_ = FrameBufferState.AWAITING_REGISTER_WRITE;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 改变secltionKey的感兴趣事件</span></span><br><span class="line">     requestSelectInterestChange();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * When this FrameBuffer needs to change its select interests and execution</span></span><br><span class="line"><span class="comment">    * might not be in its select thread, then this method will make sure the</span></span><br><span class="line"><span class="comment">    * interest change gets done when the select thread wakes back up. When the</span></span><br><span class="line"><span class="comment">    * current thread is this FrameBuffer's select thread, then it just does the</span></span><br><span class="line"><span class="comment">    * interest change immediately.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">requestSelectInterestChange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (Thread.currentThread() == <span class="keyword">this</span>.selectThread_) &#123;</span><br><span class="line">       changeSelectInterests();</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 利用work线程时,唤醒selectThread</span></span><br><span class="line">       <span class="keyword">this</span>.selectThread_.requestSelectInterestChange(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>AbstractSelectThread</p>
<figure class="highlight java"><figcaption><span>AbstractSelectThread-requestSelectInterestChange</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestSelectInterestChange</span><span class="params">(FrameBuffer frameBuffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (selectInterestChanges) &#123;</span><br><span class="line">      selectInterestChanges.add(frameBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// wakeup the selector, if it's currently blocked.</span></span><br><span class="line">    selector.wakeup();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Give this FrameBuffer a chance to set its interest to write, once data</span></span><br><span class="line"><span class="comment">   * has come in.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeSelectInterests</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state_ == FrameBufferState.AWAITING_REGISTER_WRITE) &#123;</span><br><span class="line"><span class="comment">// 注册写入事件</span></span><br><span class="line">      <span class="comment">// set the OP_WRITE interest</span></span><br><span class="line">      selectionKey_.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line">      state_ = FrameBufferState.WRITING;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state_ == FrameBufferState.AWAITING_REGISTER_READ) &#123;</span><br><span class="line"><span class="comment">// 准备重新读入，相当于重置为刚创建时的状态</span></span><br><span class="line">      prepareRead();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state_ == FrameBufferState.AWAITING_CLOSE) &#123;</span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line">      close();</span><br><span class="line">      selectionKey_.cancel();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      LOGGER.error(<span class="string">"changeSelectInterest was called, but state is invalid ("</span> + state_ + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * We're done writing, so reset our interest ops and change state</span></span><br><span class="line"><span class="comment">   * accordingly.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// we can set our interest directly without using the queue because</span></span><br><span class="line">    <span class="comment">// we're in the select thread.</span></span><br><span class="line">    selectionKey_.interestOps(SelectionKey.OP_READ);</span><br><span class="line">    <span class="comment">// get ready for another go-around</span></span><br><span class="line">    buffer_ = ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">    state_ = FrameBufferState.READING_FRAME_SIZE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span>AbstractSelectThread-执行write方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Let a writable client get written, if there's data to be written.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleWrite</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">     FrameBuffer buffer = (FrameBuffer) key.attachment();</span><br><span class="line">     <span class="keyword">if</span> (!buffer.write()) &#123;</span><br><span class="line">       cleanupSelectionKey(key);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------FrameBuffer中具体的write输出方法----------------</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Give this FrameBuffer a chance to write its output to the final client.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (state_ == FrameBufferState.WRITING) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">	  <span class="comment">// 写失败直接返回</span></span><br><span class="line">         <span class="keyword">if</span> (trans_.write(buffer_) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         LOGGER.warn(<span class="string">"Got an IOException during write!"</span>, e);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 写完了，重新回到读取状态 </span></span><br><span class="line">       <span class="comment">// we're done writing. now we need to switch back to reading.</span></span><br><span class="line">       <span class="keyword">if</span> (buffer_.remaining() == <span class="number">0</span>) &#123;</span><br><span class="line">         prepareRead();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     LOGGER.error(<span class="string">"Write was called, but state is invalid ("</span> + state_ + <span class="string">")"</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ****************  FrameBufferedTransport中 的write方法 ********</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> TTransportException </span>&#123;</span><br><span class="line">    writeBuffer_.write(buf, off, len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> TTransportException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buf = writeBuffer_.get();</span><br><span class="line">    <span class="keyword">int</span> len = writeBuffer_.len();</span><br><span class="line">    writeBuffer_.reset();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 编码frameSize</span></span><br><span class="line">    encodeFrameSize(len, i32buf);</span><br><span class="line">	<span class="comment">// 写入4个字节的整数长度</span></span><br><span class="line">    transport_.write(i32buf, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">	<span class="comment">// 写入具体的内容</span></span><br><span class="line">    transport_.write(buf, <span class="number">0</span>, len);</span><br><span class="line">    transport_.flush();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">encodeFrameSize</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> frameSize, <span class="keyword">final</span> <span class="keyword">byte</span>[] buf)</span> </span>&#123;</span><br><span class="line">    buf[<span class="number">0</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (frameSize &gt;&gt; <span class="number">24</span>));</span><br><span class="line">    buf[<span class="number">1</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (frameSize &gt;&gt; <span class="number">16</span>));</span><br><span class="line">    buf[<span class="number">2</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (frameSize &gt;&gt; <span class="number">8</span>));</span><br><span class="line">    buf[<span class="number">3</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (frameSize));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>TBaseProcessor</p>
<figure class="highlight java"><figcaption><span>TBaseProcessor</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TBaseProcessor</span>&lt;<span class="title">I</span>&gt; <span class="keyword">implements</span> <span class="title">TProcessor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> I iface;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String,ProcessFunction&lt;I, ? extends TBase&gt;&gt; processMap;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">TBaseProcessor</span><span class="params">(I iface, Map&lt;String, ProcessFunction&lt;I, ? extends TBase&gt;&gt; processFunctionMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.iface = iface;</span><br><span class="line">    <span class="keyword">this</span>.processMap = processFunctionMap;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Map&lt;String,ProcessFunction&lt;I, ? extends TBase&gt;&gt; getProcessMapView() &#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableMap(processMap);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(TProtocol in, TProtocol out)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    TMessage msg = in.readMessageBegin();</span><br><span class="line">	<span class="comment">// 获取对应的调用方法</span></span><br><span class="line">    ProcessFunction fn = processMap.get(msg.name);</span><br><span class="line">    <span class="keyword">if</span> (fn == <span class="keyword">null</span>) &#123;</span><br><span class="line">      TProtocolUtil.skip(in, TType.STRUCT);</span><br><span class="line">      in.readMessageEnd();</span><br><span class="line">      TApplicationException x = <span class="keyword">new</span> TApplicationException(TApplicationException.UNKNOWN_METHOD, <span class="string">"Invalid method name: '"</span>+msg.name+<span class="string">"'"</span>);</span><br><span class="line">      out.writeMessageBegin(<span class="keyword">new</span> TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));</span><br><span class="line">      x.write(out);</span><br><span class="line">      out.writeMessageEnd();</span><br><span class="line">      out.getTransport().flush();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fn.process(msg.seqid, in, out, iface);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ProcessFunction的处理过程</p>
<figure class="highlight java"><figcaption><span>ProcessFunction</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessFunction</span>&lt;<span class="title">I</span>, <span class="title">T</span> <span class="keyword">extends</span> <span class="title">TBase</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String methodName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ProcessFunction.class.getName());</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ProcessFunction</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.methodName = methodName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> seqid, TProtocol iprot, TProtocol oprot, I iface)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">	<span class="comment">// 初始化空参数实例 </span></span><br><span class="line">    T args = getEmptyArgsInstance();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">	  <span class="comment">// 读取参数</span></span><br><span class="line">      args.read(iprot);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TProtocolException e) &#123;</span><br><span class="line">      iprot.readMessageEnd();</span><br><span class="line">      TApplicationException x = <span class="keyword">new</span> TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());</span><br><span class="line">      oprot.writeMessageBegin(<span class="keyword">new</span> TMessage(getMethodName(), TMessageType.EXCEPTION, seqid));</span><br><span class="line">      x.write(oprot);</span><br><span class="line">      oprot.writeMessageEnd();</span><br><span class="line">      oprot.getTransport().flush();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取参数结果 </span></span><br><span class="line">    iprot.readMessageEnd();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    TBase result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">	  <span class="comment">// 调用方法并获取返回结果 </span></span><br><span class="line">      result = getResult(iface, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Throwable th) &#123;</span><br><span class="line">      LOGGER.error(<span class="string">"Internal error processing "</span> + getMethodName(), th);</span><br><span class="line">      TApplicationException x = <span class="keyword">new</span> TApplicationException(TApplicationException.INTERNAL_ERROR, </span><br><span class="line">        <span class="string">"Internal error processing "</span> + getMethodName());</span><br><span class="line">      oprot.writeMessageBegin(<span class="keyword">new</span> TMessage(getMethodName(), TMessageType.EXCEPTION, seqid));</span><br><span class="line">      x.write(oprot);</span><br><span class="line">      oprot.writeMessageEnd();</span><br><span class="line">      oprot.getTransport().flush();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!isOneway()) &#123;</span><br><span class="line">      oprot.writeMessageBegin(<span class="keyword">new</span> TMessage(getMethodName(), TMessageType.REPLY, seqid));</span><br><span class="line">      result.write(oprot);</span><br><span class="line">      oprot.writeMessageEnd();</span><br><span class="line">      oprot.getTransport().flush();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isOneway</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取结果输出的抽象方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TBase <span class="title">getResult</span><span class="params">(I iface, T args)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参数实例的抽象方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">getEmptyArgsInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getMethodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> methodName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例方法调用 </p>
<figure class="highlight java"><figcaption><span>addFolder_result</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> addFolder_result <span class="title">getResult</span><span class="params">(I iface, addFolder_args args)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">	<span class="comment">// 创建一个result 对象</span></span><br><span class="line">       addFolder_result result = <span class="keyword">new</span> addFolder_result();</span><br><span class="line">	<span class="comment">// 进行方法调用 </span></span><br><span class="line">       result.success = iface.addFolder(args.userId, args.name, args.isPublic);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// *********实现方便 协议层 调用 的read 和 write 方法******************</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(org.apache.thrift.protocol.TProtocol iprot)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">     schemes.get(iprot.getScheme()).getScheme().read(iprot, <span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(org.apache.thrift.protocol.TProtocol oprot)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">     schemes.get(oprot.getScheme()).getScheme().write(oprot, <span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ******实现了 writeObject 和 readObject 方法***************</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream out)</span> <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       write(<span class="keyword">new</span> org.apache.thrift.protocol.TCompactProtocol(<span class="keyword">new</span> org.apache.thrift.transport.TIOStreamTransport(out)));</span><br><span class="line">     &#125; <span class="keyword">catch</span> (org.apache.thrift.TException te) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> java.io.IOException(te);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       read(<span class="keyword">new</span> org.apache.thrift.protocol.TCompactProtocol(<span class="keyword">new</span> org.apache.thrift.transport.TIOStreamTransport(in)));</span><br><span class="line">     &#125; <span class="keyword">catch</span> (org.apache.thrift.TException te) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> java.io.IOException(te);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// *******************真正实现读写的地方***************</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">addFolder_resultStandardScheme</span> <span class="keyword">extends</span> <span class="title">StandardScheme</span>&lt;<span class="title">addFolder_result</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(org.apache.thrift.protocol.TProtocol iprot, addFolder_result struct)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">       org.apache.thrift.protocol.TField schemeField;</span><br><span class="line">       iprot.readStructBegin();</span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">       &#123;</span><br><span class="line">         schemeField = iprot.readFieldBegin();</span><br><span class="line">         <span class="keyword">if</span> (schemeField.type == org.apache.thrift.protocol.TType.STOP) &#123; </span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">switch</span> (schemeField.id) &#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// SUCCESS</span></span><br><span class="line">             <span class="keyword">if</span> (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) &#123;</span><br><span class="line">               struct.success = <span class="keyword">new</span> CodeMsg();</span><br><span class="line">               struct.success.read(iprot);</span><br><span class="line">               struct.setSuccessIsSet(<span class="keyword">true</span>);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">               org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">             org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);</span><br><span class="line">         &#125;</span><br><span class="line">         iprot.readFieldEnd();</span><br><span class="line">       &#125;</span><br><span class="line">       iprot.readStructEnd();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// check for required fields of primitive type, which can't be checked in the validate method</span></span><br><span class="line">       struct.validate();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(org.apache.thrift.protocol.TProtocol oprot, addFolder_result struct)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">       struct.validate();</span><br><span class="line"></span><br><span class="line">       oprot.writeStructBegin(STRUCT_DESC);</span><br><span class="line">       <span class="keyword">if</span> (struct.success != <span class="keyword">null</span>) &#123;</span><br><span class="line">         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);</span><br><span class="line">	  <span class="comment">// struct.success 是CodeMsg 对象</span></span><br><span class="line">         struct.success.write(oprot);</span><br><span class="line">         oprot.writeFieldEnd();</span><br><span class="line">       &#125;</span><br><span class="line">       oprot.writeFieldStop();</span><br><span class="line">       oprot.writeStructEnd();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再看CodeMsg 对象</p>
<figure class="highlight java"><figcaption><span>CodeMsgStandardScheme</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeMsgStandardScheme</span> <span class="keyword">extends</span> <span class="title">StandardScheme</span>&lt;<span class="title">CodeMsg</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(org.apache.thrift.protocol.TProtocol iprot, CodeMsg struct)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">      org.apache.thrift.protocol.TField schemeField;</span><br><span class="line">      iprot.readStructBegin();</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        schemeField = iprot.readFieldBegin();</span><br><span class="line">        <span class="keyword">if</span> (schemeField.type == org.apache.thrift.protocol.TType.STOP) &#123; </span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (schemeField.id) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// CODE</span></span><br><span class="line">            <span class="keyword">if</span> (schemeField.type == org.apache.thrift.protocol.TType.I32) &#123;</span><br><span class="line">              struct.code = iprot.readI32();</span><br><span class="line">              struct.setCodeIsSet(<span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// MSG</span></span><br><span class="line">            <span class="keyword">if</span> (schemeField.type == org.apache.thrift.protocol.TType.STRING) &#123;</span><br><span class="line">              struct.msg = iprot.readString();</span><br><span class="line">              struct.setMsgIsSet(<span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);</span><br><span class="line">        &#125;</span><br><span class="line">        iprot.readFieldEnd();</span><br><span class="line">      &#125;</span><br><span class="line">      iprot.readStructEnd();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// check for required fields of primitive type, which can't be checked in the validate method</span></span><br><span class="line">      <span class="keyword">if</span> (!struct.isSetCode()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> org.apache.thrift.protocol.TProtocolException(<span class="string">"Required field 'code' was not found in serialized data! Struct: "</span> + toString());</span><br><span class="line">      &#125;</span><br><span class="line">      struct.validate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// CodeMsg 的写入操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(org.apache.thrift.protocol.TProtocol oprot, CodeMsg struct)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">      struct.validate();</span><br><span class="line">	  <span class="comment">// 写入结构体名称</span></span><br><span class="line">      oprot.writeStructBegin(STRUCT_DESC);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">// 开始写入code 字段名</span></span><br><span class="line">      oprot.writeFieldBegin(CODE_FIELD_DESC);</span><br><span class="line">	  <span class="comment">// 写入code 字段值</span></span><br><span class="line">      oprot.writeI32(struct.code);</span><br><span class="line">	  <span class="comment">// 写入一个字段完成</span></span><br><span class="line">      oprot.writeFieldEnd();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (struct.msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">        oprot.writeFieldBegin(MSG_FIELD_DESC);</span><br><span class="line">        oprot.writeString(struct.msg);</span><br><span class="line">        oprot.writeFieldEnd();</span><br><span class="line">      &#125;</span><br><span class="line">	  <span class="comment">// 停止字段写入</span></span><br><span class="line">      oprot.writeFieldStop();</span><br><span class="line">	  <span class="comment">// 写入当前对象完成</span></span><br><span class="line">      oprot.writeStructEnd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer2">
      <div id="footer-info" class="inner">
        <a href="http://www.618shoe.com/">莆田1:1精仿鞋微信号</a>
        <a href="http://www.618shoe.com/">莆田高仿鞋子的价格表</a>
        <a href="http://www.618shoe.com/">关于莆田仿鞋</a>
        <a href="http://www.618shoe.com/">莆田高仿鞋淘宝店店名</a>
        <a href="http://www.618shoe.com/">莆田精仿鞋官网</a>
         咨询QQ：<a title="点击这里给我发消息" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2727291807&amp;site=www.cactussoft.cn&amp;menu=yes" target="_blank"><img src="http://wpa.qq.com/pa?p=2:2727291807:41"></a>
      </div>
        <div id="footer-info" class="inner">
          <a href="http://www.618shoe.com/">莆田高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">1：1高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">高仿鞋批发市场</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">高仿鞋网</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">广州高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">外贸尾单鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">精仿鞋专线</a>&nbsp;&nbsp;
      </div>
      <div id="footer-info" class="inner">
             <a href="http://www.618shoe.com/">莆田高仿鞋批发</a>&nbsp;&nbsp;
             公司网站:&nbsp;&nbsp;<a href="http://www.618shoe.com//" target="_blank">http://www.618shoe.com/</a>&nbsp;&nbsp;
             <a href="http://www.618shoe.com/">高仿鞋批发市场</a>
             微信 <img src="/pics/qrcode.jpg" style="width:100px;height:100px;">
      </div>
    </footer>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2012/12/18/thrift-src-study/" data-id="cja9q2aci0014nh5isw6ofwwm" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-consistent-hashing" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2012/12/18/consistent-hashing/" class="article-date">
  <time datetime="2012-12-18T10:59:00.000Z" itemprop="datePublished">2012-12-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/12/18/consistent-hashing/">一致性哈希学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>####一、背景  </p>
<p>常见的互联网应用为了提供系统的性能通过会把许多数据放在缓存中。为了避免单点故障或是分担压力，通过会有n台缓存服务器。  </p>
<p>数据应该如何在这些缓存服务器节点上分配，性能、可拓展性、复杂性？</p>
<p>####二、经典解决方案</p>
<p>3~5个缓存节点</p>
<p>采用“ hash(key) mod n ”的策略来分配数据放到对应的缓存服务器。</p>
<p><strong>缺点</strong>：  </p>
<ol>
<li>如果某台缓存服务器当机了，除非进行人工干预，否则分配到该当机缓存服务器的缓存数据会一直失效，将压力直接打在后端数据库上。</li>
<li>当缓存集群需要横向拓展时，例如添加一个服务则会导致原先分配的部分缓存数据失效。</li>
<li>数据分布不均匀，无法进行调整。</li>
</ol>
<p>####三、一致性哈希<br>(摘自：<a href="http://www.yeeach.com/?p=591" target="_blank" rel="noopener">Consistent Hashing算法</a>)</p>
<p>由于hash算法结果一般为unsigned int型，因此对于hash函数的结果应该均匀分布在[0,232-1]间，如果我们把一个圆环用232  个点来进行均匀切割，首先按照hash(key)函数算出服务器（节点）的哈希值， 并将其分布到0～232的圆上。</p>
<p>用同样的hash(key)函数求出需要存储数据的键的哈希值，并映射到圆上。然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器（节点）上。</p>
<p><img src="/pics/memcached-0004-04.png" alt=""></p>
<p>新增一个节点的时候，只有在圆环上新增节点逆时针方向的第一个节点的数据会受到影响。删除一个节点的时候，只有在圆环上原来删除节点顺时针方向的第一个节点的数据会受到影响，因此通过Consistent Hashing很好地解决了负载均衡中由于新增节点、删除节点引起的hash值颠簸问题。</p>
<p><img src="/pics/memcached-0004-05.png" alt=""></p>
<p><strong>虚拟节点（virtual nodes）</strong>：之所以要引进虚拟节点是因为在服务器（节点）数较少的情况下（例如只有3台服务器），通过hash(key)算出节点的哈希值在圆环上并不是均匀分布的（稀疏的），仍然会出现各节点负载不均衡的问题。虚拟节点可以认为是实际节点的复制品（replicas），本质上与实际节点实际上是一样的（key并不相同）。引入虚拟节点后，通过将每个实际的服务器（节点）数按照一定的比例(例如200倍)扩大后并计算其hash(key)值以均匀分布到圆环上。在进行负载均衡时候，落到虚拟节点的哈希值实际就落到了实际的节点上。由于所有的实际节点是按照相同的比例复制成虚拟节点的，因此解决了节点数较少的情况下哈希值在圆环上均匀分布的问题。</p>
<p><img src="/pics/chgraph-thumb.png" alt=""></p>
<p><strong>虚拟节点对Consistent Hashing结果的影响</strong></p>
<p>从上图可以看出，在节点数为10个的情况下，每个实际节点的虚拟节点数为实际节点的100-200倍的时候，结果还是很均衡的。</p>
<p><strong>好处</strong>：</p>
<ol>
<li>如果存在某个缓存节点失效，可以分担压力到所有存活的节点。</li>
<li>采用虚拟节点，可以使每个实际缓存节点分担的压力更加均匀。</li>
<li>添加一台服务器时，可以分担所有缓存服务器的压力。</li>
</ol>
<p>#####四、 jedis中一致性哈希的使用</p>
<h5 id="1-用来存储redis分片信息的ShardInfo"><a href="#1-用来存储redis分片信息的ShardInfo" class="headerlink" title="1. 用来存储redis分片信息的ShardInfo"></a>1. 用来存储redis分片信息的ShardInfo</h5><pre><code>package redis.clients.util;

public abstract class ShardInfo&lt;T&gt; {
    private int weight;

    public ShardInfo() {
    }

    public ShardInfo(int weight) {
        this.weight = weight;
    }

    public int getWeight() {
        return this.weight;
    }

    protected abstract T createResource();

    public abstract String getName();
}
</code></pre><h5 id="2-初始化构造jedis-shard-构成的虚拟节点环"><a href="#2-初始化构造jedis-shard-构成的虚拟节点环" class="headerlink" title="2. 初始化构造jedis shard 构成的虚拟节点环"></a>2. 初始化构造jedis shard 构成的虚拟节点环</h5><p><strong>redis.clients.util.Sharded</strong></p>
<pre><code>// 传入shards(即redis缓存服务器信息)列表
private void initialize(List&lt;S&gt; shards) {
    // 构造一个有序的Map,以便在查找时匹配到邻近的结点
    nodes = new TreeMap&lt;Long, S&gt;();

    for (int i = 0; i != shards.size(); ++i) {
        final S shardInfo = shards.get(i);
        if (shardInfo.getName() == null)// shard名称为空
            // 每个shard 生成 160 * weight 个虚拟节点，保证数据分布的均匀
            for (int n = 0; n &lt; 160 * shardInfo.getWeight(); n++) {
                nodes.put(this.algo.hash(&quot;SHARD-&quot; + i + &quot;-NODE-&quot; + n), shardInfo);
            }
        else
            for (int n = 0; n &lt; 160 * shardInfo.getWeight(); n++) {
                nodes.put(this.algo.hash(shardInfo.getName() + &quot;*&quot; + shardInfo.getWeight() + n), shardInfo);
            }
        // 存放shardInfo 与真实jedis 连接
        resources.put(shardInfo, shardInfo.createResource());
    }
}
</code></pre><h5 id="3-根据key-获取对应的缓存服务器资源"><a href="#3-根据key-获取对应的缓存服务器资源" class="headerlink" title="3. 根据key 获取对应的缓存服务器资源"></a>3. 根据key 获取对应的缓存服务器资源</h5><pre><code>public R getShard(byte[] key) {
    return resources.get(getShardInfo(key));
}

// 获取key 对应的jedis资源
public R getShard(String key) {
    // 先获取key 对应的shardInfo
    return resources.get(getShardInfo(key));
}

// 获取key 对应的shardInfo
public S getShardInfo(byte[] key) {
    // 从nodes 的treeMap 找出大于或等于 hash（key）的值的SortedMap视图
    SortedMap&lt;Long, S&gt; tail = nodes.tailMap(algo.hash(key));
    if (tail.size() == 0) {
        // 如果结果集为空，则取默认的第一个节点
        return nodes.get(nodes.firstKey());
    }
    // 返回结果集的第一个节点，即最接近hash(key)值的节点
    return tail.get(tail.firstKey());
}

public S getShardInfo(String key) {
    return getShardInfo(SafeEncoder.encode(getKeyTag(key)));
}
</code></pre><h5 id="4-默认的Shard构造中使用-MURMUR-HASH-算法（传说中最快的Hash算法）"><a href="#4-默认的Shard构造中使用-MURMUR-HASH-算法（传说中最快的Hash算法）" class="headerlink" title="4. 默认的Shard构造中使用 MURMUR_HASH 算法（传说中最快的Hash算法）"></a>4. 默认的Shard构造中使用 MURMUR_HASH 算法（传说中最快的Hash算法）</h5><p>code:</p>
<pre><code>public Sharded(List&lt;S&gt; shards) {
    this(shards, Hashing.MURMUR_HASH); // MD5 is really not good as we works
    // with 64-bits not 128
}
</code></pre><h5 id="5-Hashing-infterface"><a href="#5-Hashing-infterface" class="headerlink" title="5. Hashing infterface"></a>5. Hashing infterface</h5><pre><code>public interface Hashing {
    public static final Hashing MURMUR_HASH = new MurmurHash();
    // 由于JDK中的MD5算法不是线程安全的，所以利用ThreadLocal为每个线程保存一个MD5算法的实例 
    public ThreadLocal&lt;MessageDigest&gt; md5Holder = new ThreadLocal&lt;MessageDigest&gt;();

    // MD5 Hash哈希算法的实现
    public static final Hashing MD5 = new Hashing() {
        public long hash(String key) {
            return hash(SafeEncoder.encode(key));
        }

        public long hash(byte[] key) {
            try {
                if (md5Holder.get() == null) {
                    md5Holder.set(MessageDigest.getInstance(&quot;MD5&quot;));
                }
            } catch (NoSuchAlgorithmException e) {
                throw new IllegalStateException(&quot;++++ no md5 algorythm found&quot;);
            }
            MessageDigest md5 = md5Holder.get();

            md5.reset();
            md5.update(key);
            byte[] bKey = md5.digest();
            long res = ((long) (bKey[3] &amp; 0xFF) &lt;&lt; 24)
                    | ((long) (bKey[2] &amp; 0xFF) &lt;&lt; 16)
                    | ((long) (bKey[1] &amp; 0xFF) &lt;&lt; 8) | (long) (bKey[0] &amp; 0xFF);
            return res;
        }
    };

    public long hash(String key);

    public long hash(byte[] key);
}
</code></pre><h4 id="五、xmemcached-中一致性哈希的使用"><a href="#五、xmemcached-中一致性哈希的使用" class="headerlink" title="五、xmemcached 中一致性哈希的使用"></a>五、xmemcached 中一致性哈希的使用</h4><p><a href="https://github.com/killme2008/xmemcached/blob/master/src/main/java/net/rubyeye/xmemcached/impl/KetamaMemcachedSessionLocator.java" target="_blank" rel="noopener">net.rubyeye.xmemcached.impl.KetamaMemcachedSessionLocator</a></p>
<p>#####1. 初始化构造虚拟节点的圆环</p>
<pre><code>private final void buildMap(Collection&lt;Session&gt; list, HashAlgorithm alg) {
    TreeMap&lt;Long, List&lt;Session&gt;&gt; sessionMap = new TreeMap&lt;Long, List&lt;Session&gt;&gt;();

    String sockStr;
    for (Session session : list) {
        if (this.cwNginxUpstreamConsistent) {
            InetSocketAddress serverAddress = session
                    .getRemoteSocketAddress();
            sockStr = serverAddress.getAddress().getHostAddress();
            if (serverAddress.getPort() != DEFAULT_PORT) {
                sockStr = sockStr + &quot;:&quot; + serverAddress.getPort();
            }
        } else {
            sockStr = String.valueOf(session.getRemoteSocketAddress());
        }
        /**
         * Duplicate 160 X weight references
         */
        int numReps = NUM_REPS;
        if (session instanceof MemcachedTCPSession) {
            numReps *= ((MemcachedSession) session).getWeight();
        }
        if (alg == HashAlgorithm.KETAMA_HASH) {
            for (int i = 0; i &lt; numReps / 4; i++) {
                byte[] digest = HashAlgorithm.computeMd5(sockStr + &quot;-&quot; + i);
                for (int h = 0; h &lt; 4; h++) {
                    long k = (long) (digest[3 + h * 4] &amp; 0xFF) &lt;&lt; 24
                            | (long) (digest[2 + h * 4] &amp; 0xFF) &lt;&lt; 16
                            | (long) (digest[1 + h * 4] &amp; 0xFF) &lt;&lt; 8
                            | digest[h * 4] &amp; 0xFF;
                    this.getSessionList(sessionMap, k).add(session);
                }

            }
        } else {
            for (int i = 0; i &lt; numReps; i++) {
                long key = alg.hash(sockStr + &quot;-&quot; + i);
                this.getSessionList(sessionMap, key).add(session);
            }
        }
    }
    this.ketamaSessions = sessionMap;
    this.maxTries = list.size();
}
</code></pre><p>#####2. 根据hash值获取对应的memcached session</p>
<pre><code>public final Session getSessionByHash(final long hash) {
    TreeMap&lt;Long, List&lt;Session&gt;&gt; sessionMap = this.ketamaSessions;
    if (sessionMap.size() == 0) {
        return null;
    }
    Long resultHash = hash;
    if (!sessionMap.containsKey(hash)) {
        // Java 1.6 adds a ceilingKey method, but xmemcached is compatible
        // with jdk5,So use tailMap method to do this.
        SortedMap&lt;Long, List&lt;Session&gt;&gt; tailMap = sessionMap.tailMap(hash);
        if (tailMap.isEmpty()) {
            resultHash = sessionMap.firstKey();
        } else {
            resultHash = tailMap.firstKey();
        }
    }
    //
    // if (!sessionMap.containsKey(resultHash)) {
    // resultHash = sessionMap.ceilingKey(resultHash);
    // if (resultHash == null &amp;&amp; sessionMap.size() &gt; 0) {
    // resultHash = sessionMap.firstKey();
    // }
    // }
    List&lt;Session&gt; sessionList = sessionMap.get(resultHash);
    if (sessionList == null || sessionList.size() == 0) {
        return null;
    }
    int size = sessionList.size();
    return sessionList.get(this.random.nextInt(size));
}
</code></pre><p>一致性Hash的问题：  </p>
<ol>
<li>发何解决解决单点故障?(来自Tim的博客)<blockquote>
<p>是否像Dynamo那样写入到多个节点(或双写)？如果双写所有的服务器需要消耗2倍的内存及更多CPU资源。</p>
</blockquote>
</li>
</ol>
<p>参考资料  </p>
<ul>
<li><a href="http://www.yeeach.com/?p=591" target="_blank" rel="noopener">Consistent Hashing算法</a>  </li>
<li><a href="http://weblogs.java.net/blog/tomwhite/archive/2007/11/consistent_hash.html" target="_blank" rel="noopener">Consistent Hashing</a>  </li>
<li><a href="http://tech.idv2.com/2008/07/24/memcached-004/" target="_blank" rel="noopener">memcached全面剖析–4. memcached的分布式算法</a>  </li>
<li><a href="http://stblog.baidu-tech.com/?p=42" target="_blank" rel="noopener">“分布式哈希”和“一致性哈希”的概念与算法实现</a> - 百度搜索研发部官方博客</li>
<li><a href="http://timyang.net/architecture/consistent-hashing-practice/" target="_blank" rel="noopener">某分布式应用实践一致性哈希的一些问题</a> - TimYang   </li>
<li><a href="http://dbanotes.net/tech-memo/amazon_dynamo.html" target="_blank" rel="noopener">Amazon 的 Dynamo 架构</a>- DBANotes</li>
</ul>

      
    </div>
    <footer class="article-footer2">
      <div id="footer-info" class="inner">
        <a href="http://www.618shoe.com/">莆田1:1精仿鞋微信号</a>
        <a href="http://www.618shoe.com/">莆田高仿鞋子的价格表</a>
        <a href="http://www.618shoe.com/">关于莆田仿鞋</a>
        <a href="http://www.618shoe.com/">莆田高仿鞋淘宝店店名</a>
        <a href="http://www.618shoe.com/">莆田精仿鞋官网</a>
         咨询QQ：<a title="点击这里给我发消息" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2727291807&amp;site=www.cactussoft.cn&amp;menu=yes" target="_blank"><img src="http://wpa.qq.com/pa?p=2:2727291807:41"></a>
      </div>
        <div id="footer-info" class="inner">
          <a href="http://www.618shoe.com/">莆田高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">1：1高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">高仿鞋批发市场</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">高仿鞋网</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">广州高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">外贸尾单鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">精仿鞋专线</a>&nbsp;&nbsp;
      </div>
      <div id="footer-info" class="inner">
             <a href="http://www.618shoe.com/">莆田高仿鞋批发</a>&nbsp;&nbsp;
             公司网站:&nbsp;&nbsp;<a href="http://www.618shoe.com//" target="_blank">http://www.618shoe.com/</a>&nbsp;&nbsp;
             <a href="http://www.618shoe.com/">高仿鞋批发市场</a>
             微信 <img src="/pics/qrcode.jpg" style="width:100px;height:100px;">
      </div>
    </footer>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2012/12/18/consistent-hashing/" data-id="cja9q2acg0012nh5ik7gf7058" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java-nio-channel" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2012/12/18/java-nio-channel/" class="article-date">
  <time datetime="2012-12-18T06:46:00.000Z" itemprop="datePublished">2012-12-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java-NIO/">Java NIO</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/12/18/java-nio-channel/">Java NIO Channel</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>《Java NIO》学习笔记 —— Channel篇</p>
<p>####Channel的类层次图</p>
<p><img src="/pics/java-nio-channel-class.jpg" alt="java channels class"><br><a href="/pics/java-nio-channel-class.jpg">点击查看大图</a></p>
<p>channel 主要分为 WritableByteChannel,ReadableByteChannel 以及 NetworkChannel.<br>图中有一个 FileChannel类和三个socket通道类：SocketChannel,ServerSocketChannel 和 DatagramChannel.</p>
<p>####Channel通道的接口</p>
<pre><code>public interface Channel extends Closeable {
    public boolean isOpen();
    public void close() throws IOException;
}
</code></pre><p>####打开Channel</p>
<p>#####1.socket Channel</p>
<p>socket Channel可以直接被创建</p>
<pre><code>SocketChannel sc = SocketChannel.open();
sc.connect(new InetSocketAddress(&quot;host&quot;,port));

ServerSocketChannel ssc = ServerSocketChannel.open();
ssc.socket().bind(new InetSocketAddress(port));

DatagramChannel dc = DatagramChannel.open();
</code></pre><p>#####2. FileChannel  </p>
<p>FileChannel只能通过一个打开的RandomAccessFile、FileInputStream或FileOutputStream 对象上调用getChannel()方法来获取，不能直接创建一个FileChannel对象。</p>
<pre><code>RandomAccessFile raf = new RandomAccessFile(&quot;filename&quot;,&quot;r&quot;);
FileChannel fc = raf.getChannel();
</code></pre><p><strong>对比</strong>：<br>Socket 对象上的getChannel方法: public SocketChannel getChannel(),并不会创建一个channel,当且仅当通过 SocketChannel.open 或 ServerSocketChannel.accept 方法创建了通道本身时，套接字才具有一个通道。</p>
<p>####使用Channel</p>
<pre><code>public interface ReadableByteChannel extends Channel {
    public int read(ByteBuffer dst) throws IOException;
}

public interface WritableByteChannel extends Channel{
    public int write(ByteBuffer src) throws IOException;
}

public interface ByteChannel extends ReadableByteChannel, WritableByteChannel{

}
</code></pre><p>Java的每个file或socket channel 都实现这三个接口，file channel 是否可以读写取决于底层打开文件的方式。<br>例如：</p>
<pre><code>FileInputStream is = new FileInputStream(fileName);
FileChannel fc = is.getChannel();
</code></pre><p>从输入流获取的FileChannle只能读取，而不能写入。  </p>
<p>Channel 可以以阻塞或非阻塞方式运行。非阻塞的方式永远不会用调用的线程休眠，请求操作要么立即返回，要么返回一个结果表明未进行任何操作。</p>

      
    </div>
    <footer class="article-footer2">
      <div id="footer-info" class="inner">
        <a href="http://www.618shoe.com/">莆田1:1精仿鞋微信号</a>
        <a href="http://www.618shoe.com/">莆田高仿鞋子的价格表</a>
        <a href="http://www.618shoe.com/">关于莆田仿鞋</a>
        <a href="http://www.618shoe.com/">莆田高仿鞋淘宝店店名</a>
        <a href="http://www.618shoe.com/">莆田精仿鞋官网</a>
         咨询QQ：<a title="点击这里给我发消息" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2727291807&amp;site=www.cactussoft.cn&amp;menu=yes" target="_blank"><img src="http://wpa.qq.com/pa?p=2:2727291807:41"></a>
      </div>
        <div id="footer-info" class="inner">
          <a href="http://www.618shoe.com/">莆田高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">1：1高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">高仿鞋批发市场</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">高仿鞋网</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">广州高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">外贸尾单鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">精仿鞋专线</a>&nbsp;&nbsp;
      </div>
      <div id="footer-info" class="inner">
             <a href="http://www.618shoe.com/">莆田高仿鞋批发</a>&nbsp;&nbsp;
             公司网站:&nbsp;&nbsp;<a href="http://www.618shoe.com//" target="_blank">http://www.618shoe.com/</a>&nbsp;&nbsp;
             <a href="http://www.618shoe.com/">高仿鞋批发市场</a>
             微信 <img src="/pics/qrcode.jpg" style="width:100px;height:100px;">
      </div>
    </footer>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2012/12/18/java-nio-channel/" data-id="cja9q2acf0010nh5io1wl6xls" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java-nio-char-buffer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2012/12/18/java-nio-char-buffer/" class="article-date">
  <time datetime="2012-12-18T03:47:00.000Z" itemprop="datePublished">2012-12-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java-NIO/">Java NIO</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/12/18/java-nio-char-buffer/">Java NIO Char Buffer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>《Java NIO》学习笔记 —— Char Buffer篇</p>
<p>####字节顺序</p>
<p>java.nio.ByteOrder 字节顺序的类型安全枚举。  </p>
<ul>
<li>BIG_ENDIAN 表示 big-endian 字节顺序的常量。</li>
<li>LITTLE_ENDIAN 表示 little-endian 字节顺序的常量。</li>
<li>nativeOrder() 获取底层平台的本机字节顺序。</li>
</ul>
<p>IP协议规定了使用大端的网络字节顺序。  </p>
<p>除ByteBuffer外的 Buffer通过创建或包装数组元素产生的, 其order方法返回的字节序与 ByteOrder.nativeOrder()返回的值相同;<br>如果作为ByteBuffer 的视图缓冲区而创建的Buffer，缓冲区的字节顺序是创建视图时ByteBuffer缓冲区的字节顺序。</p>
<p>ByteBuffer 默认字节顺序总是 BIG_ENDIAN，无论系统固有的字节顺序是什么。ByteBuffer可以通过order(ByteOrder bo)方法来改变字节顺序。</p>

      
    </div>
    <footer class="article-footer2">
      <div id="footer-info" class="inner">
        <a href="http://www.618shoe.com/">莆田1:1精仿鞋微信号</a>
        <a href="http://www.618shoe.com/">莆田高仿鞋子的价格表</a>
        <a href="http://www.618shoe.com/">关于莆田仿鞋</a>
        <a href="http://www.618shoe.com/">莆田高仿鞋淘宝店店名</a>
        <a href="http://www.618shoe.com/">莆田精仿鞋官网</a>
         咨询QQ：<a title="点击这里给我发消息" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2727291807&amp;site=www.cactussoft.cn&amp;menu=yes" target="_blank"><img src="http://wpa.qq.com/pa?p=2:2727291807:41"></a>
      </div>
        <div id="footer-info" class="inner">
          <a href="http://www.618shoe.com/">莆田高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">1：1高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">高仿鞋批发市场</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">高仿鞋网</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">广州高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">外贸尾单鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">精仿鞋专线</a>&nbsp;&nbsp;
      </div>
      <div id="footer-info" class="inner">
             <a href="http://www.618shoe.com/">莆田高仿鞋批发</a>&nbsp;&nbsp;
             公司网站:&nbsp;&nbsp;<a href="http://www.618shoe.com//" target="_blank">http://www.618shoe.com/</a>&nbsp;&nbsp;
             <a href="http://www.618shoe.com/">高仿鞋批发市场</a>
             微信 <img src="/pics/qrcode.jpg" style="width:100px;height:100px;">
      </div>
    </footer>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2012/12/18/java-nio-char-buffer/" data-id="cja9q2ace000ynh5i844ya6wz" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java-nio-buffer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2012/12/12/java-nio-buffer/" class="article-date">
  <time datetime="2012-12-12T02:38:00.000Z" itemprop="datePublished">2012-12-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java-NIO/">Java NIO</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/12/12/java-nio-buffer/">Java NIO Buffer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>《Java NIO》学习笔记 —— Buffer篇</p>
<h4 id="Java-Buffer-类图"><a href="#Java-Buffer-类图" class="headerlink" title="Java Buffer 类图"></a>Java Buffer 类图</h4><p><img src="/pics/java-buffer-class.jpg" alt="java buffer class"></p>
<h4 id="缓存区的基本概念"><a href="#缓存区的基本概念" class="headerlink" title="缓存区的基本概念"></a>缓存区的基本概念</h4><p><strong>容量(Capacity)</strong><br>缓冲区能够容纳的数据元素的最大数量。这一容量在缓冲区创建时被设定，并且永远不能被改变。</p>
<p><strong>上界(Limit)</strong><br>缓冲区的第一个不能被读或写的元素。或者说，缓冲区现存元素的计数。</p>
<p><strong>位置（Position）</strong><br>下一个要被读或写的元素的索引。位置会自动由相应的get()和put() 方法更新。</p>
<p><strong>标志（Mark）</strong><br>一个标志位置。调用mark()来设定mark = position。调用reset() 设定position = mark。标记在设定之前是未定义的(undefined)。</p>
<p>####Buffer 的主要方法</p>
<pre><code>public abstract class Buffer {

    Buffer(int mark, int pos, int lim, int cap)

    public final int capacity() 

    public final int position()     
    public final Buffer position(int newPosition) 

    public final int limit()      
    public final Buffer limit(int newLimit)       

    public final Buffer mark()     
    public final Buffer reset() 

    public final Buffer clear()

    public final Buffer flip()
    public final Buffer rewind() 

    public final int remaining()
    public final boolean hasRemaining() 

    public abstract boolean isReadOnly();
    public abstract boolean isDirect();
}
</code></pre><p>ByteBuffer 的主要方法</p>
<pre><code>public abstract class ByteBuffer
    extends Buffer
    implements Comparable&lt;ByteBuffer&gt;{
    public abstract byte get();
    public abstract byte get(int index);
    public abstract ByteBuffer put(byte b);
    public abstract ByteBuffer put(int index, byte b);
}
</code></pre><p><strong>1. 填充</strong><br>调用put方法把byte 放入Buffer，初始状态position=0,limit = capacity;<br>buffer.put((byte)’H’).put((byte)’e’).put((byte)’l’).put((byte)’l’).put((byte)’o’);</p>
<p><strong>2. 翻转</strong><br>当写入完成后，我们需要设定上限来指定写入的有效内容的末端，然后将位置重置为0.<br>buffer.limit(buffer.position()).position(0)</p>
<p>可以用buffer.flip(); 方法将缓存区从可以继续写入的状态 翻转成一个准备读出的状态。  </p>
<p><strong>rewind()</strong> 方法与flip()类似，但不影响上界属性，它只是将位置值设回0，可以重新读取已被翻转的缓冲区的数据。<br>如果将缓冲区翻转两次，会将实际大小变为0，position和limit 都为0。</p>
<p><strong>3. 释放</strong>(即读取数据)</p>
<pre><code>int count = buffer.remaining();
byte[] bytes = new byte[cout]; 
int i = 0;
while(buffer.hasRemaining()){
    bytes[i++] = buffer.get();
}
</code></pre><p><strong>4. 压缩</strong><br>有时候只想从缓冲区释放一部分数据，而不是全部，然后重新填充。API为我们提供了compact 方法，compact 方法将会复制当前position未读取的数据到缓存区开头，然后重新设置 position = limit - position, 并将limit 恢复到capacity, limit = capacity。<br>应用场景：  </p>
<pre><code>public class ChannelCopy {

    public static void main(String[] args) throws IOException {
        ReadableByteChannel in = Channels.newChannel(System.in);
        WritableByteChannel out = Channels.newChannel(System.out);
        copyChannel(in,out);
        System.out.println(&quot;copy1&quot;);
//        copyChannel2(in,out);
//        System.out.println(&quot;copy2&quot;);
        in.close();
        out.close();
    }

    private static void copyChannel2(ReadableByteChannel src, WritableByteChannel dest) throws IOException {

        ByteBuffer buffer = ByteBuffer.allocate(1024);
        while(src.read(buffer) &gt; 0 ){
            buffer.flip();
            dest.write(buffer);
            buffer.compact();
        }

        buffer.flip();
        while(buffer.hasRemaining()){
            dest.write(buffer);
        }

    }

    private static void copyChannel(ReadableByteChannel src, WritableByteChannel dest) throws IOException {

        ByteBuffer buffer = ByteBuffer.allocate(1024);
        while(src.read(buffer) &gt; 0 ){
            buffer.flip();
            while(buffer.hasRemaining()){
                dest.write(buffer);
            }
            buffer.clear();
        }

    }

}
</code></pre><p><strong>5. 比较</strong></p>
<pre><code>public abstract class ByteBuffer implements Comparable&lt;ByteBuffer&gt;{
    public boolean equals(Object obj)
    public int compareTo(Object obj)
}
</code></pre><p>两个缓冲区被认为相等的充要条件：  </p>
<ul>
<li>两个对象类型相同。</li>
<li>两个对象都剩余同样数量的元素</li>
<li>在每个缓冲区中应被get() 方法返回的剩余数据元素序列必须一致。</li>
</ul>
<p>ByteBuffer.equals 源码</p>
<pre><code>public boolean equals(Object ob) {
    if (this == ob)
        return true;
    if (!(ob instanceof ByteBuffer))
        return false;
    ByteBuffer that = (ByteBuffer)ob;
    if (this.remaining() != that.remaining())
        return false;
    int p = this.position();
    for (int i = this.limit() - 1, j = that.limit() - 1; i &gt;= p; i--, j--)
        if (!equals(this.get(i), that.get(j)))
            return false;
    return true;
}
</code></pre><p><strong>6. 批量移动</strong></p>
<pre><code>public abstract class ByteBuffer extends Buffer implements Comparable&lt;ByteBuffer&gt;{
    public ByteBuffer get(byte[] dst, int offset, int length)  
    public ByteBuffer get(byte[] dst)  
    public ByteBuffer put(ByteBuffer src)  
    public ByteBuffer put(byte[] src, int offset, int length)  
    public final ByteBuffer put(byte[] src)
}
</code></pre><p>● 从buffer中读取数据到数组<br>ByteBuffer源码：    </p>
<pre><code>public ByteBuffer get(byte[] dst, int offset, int length) {
    checkBounds(offset, length, dst.length);
    if (length &gt; remaining())
        throw new BufferUnderflowException();
    int end = offset + length;
    for (int i = offset; i &lt; end; i++)
        dst[i] = get();
    return this;
}


public ByteBuffer get(byte[] dst) {
    return get(dst, 0, dst.length);
}
</code></pre><p> ● 把另外一个buffer剩余的数据放入Buffer中<br>ByteBuffer源码：  </p>
<pre><code>public ByteBuffer put(ByteBuffer src) {
    if (src == this)
        throw new IllegalArgumentException();
    int n = src.remaining();
    if (n &gt; remaining())
        throw new BufferOverflowException();
    for (int i = 0; i &lt; n; i++)
        put(src.get());
    return this;
}
</code></pre><p> ● 把数组元素放入Buffer中<br>ByteBuffer源码：  </p>
<pre><code>public ByteBuffer put(byte[] src, int offset, int length) {
    checkBounds(offset, length, src.length);
    if (length &gt; remaining())
        throw new BufferOverflowException();
    int end = offset + length;
    for (int i = offset; i &lt; end; i++)
        this.put(src[i]);
    return this;
}

public final ByteBuffer put(byte[] src) {
    return put(src, 0, src.length);
}
</code></pre><p><strong>7. 线程安全</strong><br>多个当前线程使用缓冲区是不安全的。如果一个缓冲区由不止一个线程使用，则应该通过适当的同步来控制对该缓冲区的访问。 </p>
<p>####参考资料</p>
<ul>
<li><a href="http://blog.csdn.net/jiang_bing/article/details/7878390" target="_blank" rel="noopener">java nio Buffer 中 compact的作用</a></li>
</ul>

      
    </div>
    <footer class="article-footer2">
      <div id="footer-info" class="inner">
        <a href="http://www.618shoe.com/">莆田1:1精仿鞋微信号</a>
        <a href="http://www.618shoe.com/">莆田高仿鞋子的价格表</a>
        <a href="http://www.618shoe.com/">关于莆田仿鞋</a>
        <a href="http://www.618shoe.com/">莆田高仿鞋淘宝店店名</a>
        <a href="http://www.618shoe.com/">莆田精仿鞋官网</a>
         咨询QQ：<a title="点击这里给我发消息" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2727291807&amp;site=www.cactussoft.cn&amp;menu=yes" target="_blank"><img src="http://wpa.qq.com/pa?p=2:2727291807:41"></a>
      </div>
        <div id="footer-info" class="inner">
          <a href="http://www.618shoe.com/">莆田高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">1：1高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">高仿鞋批发市场</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">高仿鞋网</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">广州高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">外贸尾单鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">精仿鞋专线</a>&nbsp;&nbsp;
      </div>
      <div id="footer-info" class="inner">
             <a href="http://www.618shoe.com/">莆田高仿鞋批发</a>&nbsp;&nbsp;
             公司网站:&nbsp;&nbsp;<a href="http://www.618shoe.com//" target="_blank">http://www.618shoe.com/</a>&nbsp;&nbsp;
             <a href="http://www.618shoe.com/">高仿鞋批发市场</a>
             微信 <img src="/pics/qrcode.jpg" style="width:100px;height:100px;">
      </div>
    </footer>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2012/12/12/java-nio-buffer/" data-id="cja9q2ac4000mnh5il8a83jje" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java-reflection" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2012/12/08/java-reflection/" class="article-date">
  <time datetime="2012-12-08T07:25:00.000Z" itemprop="datePublished">2012-12-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java-Reflection/">Java Reflection</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/12/08/java-reflection/">Java 反射</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java的反射允许我们在运行时动态地获取类及类成员的类型信息，动态调用类的方法或修改类的成员（Field）。</p>
<p>Java反射相关的类，除了java.lang.Class 以外，大部分都位于java.lang.reflect包下。</p>
<p>Java反射相关的对象：</p>
<ul>
<li>Class : 表示Java类相关的类型信息。</li>
<li>Field : 表示类的成员变量的类型信息。</li>
<li>Method : 表示类的成员方法的类型信息。</li>
<li>Constructor : 表示类的构造方法的类型信息。</li>
<li>Array : 表示数组类型，提供了动态根据目标类型创建数组，以及访问数组元素的静态方法。</li>
</ul>
<p>####一、获取Class 类型信息</p>
<p>#####1. 通过getClass 获取运行时实例的类型信息</p>
<pre><code>HelloClass h = new HelloClass();
System.out.println(h.getClass());

Date d = new Date();
System.out.println(d.getClass());
</code></pre><p>#####2. 通过className 加载class类型信息</p>
<pre><code>String dClassName = &quot;java.util.Date&quot;;
System.out.println(Class.forName(dClassName));
</code></pre><p>#####3. 通过类型.class 访问对象的类型信息</p>
<pre><code>System.out.println(Date.class);
System.out.println(int.class);
System.out.println(int[].class);
System.out.println(String[].class);
</code></pre><p>#####4. 原始类型的Class</p>
<p>一个Class对象实际上表示的是一个类型，而这个类型不一定是一种类。例如，int不是类，但int.class是一个Class类型的对象。</p>
<pre><code>System.out.println(Integer.class);
System.out.println(int.class);
System.out.println(&quot;Integer.class.equals(int.class)&quot; + Integer.class.equals(int.class));

System.out.println(Integer.TYPE);
System.out.println(&quot;Integer.TYPE.equals(int.class) = &quot; + Integer.TYPE.equals(int.class));
</code></pre><p><strong>结论</strong>：int.class 和 int包装类Interger.class 并不相等，可以通过 Integer.Type 返回原始类型的Class对象。</p>
<p>####二、Class 对象的主要方法</p>
<ul>
<li>forName(String className) 返回与带有给定字符串名的类或接口相关联的 Class 对象。</li>
<li>getAnnotation(Class&lt;A&gt; annotationClass) 如果存在该元素的指定类型的注释，则返回这些注释，否则返回 null。</li>
<li>getAnnotations() 返回此元素上存在的所有注释。</li>
<li>getComponentType() 返回表示数组组件类型的 Class。</li>
<li>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes) 返回一个 Constructor 对象，该对象反映此 Class 对象所表示的类或接口的指定构造方法。</li>
<li>getDeclaredConstructors() 返回 Constructor 对象的一个数组，这些对象反映此 Class 对象表示的类声明的所有构造方法。</li>
<li>getDeclaredField(String name) 返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段。</li>
<li>getDeclaredFields() 返回 Field 对象的一个数组，这些对象反映此 Class 对象所表示的类或接口所声明的所有字段。</li>
<li>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。</li>
<li>getDeclaredMethods() 返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</li>
<li>getGenericInterfaces() 返回表示某些接口的 Type，这些接口由此对象所表示的类或接口直接实现。</li>
<li>getGenericSuperclass() 返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的直接超类的 Type。</li>
<li>getSuperclass() 返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的超类的 Class。</li>
<li>isAssignableFrom(Class&lt;?&gt; cls) 判定此 Class 对象所表示的类或接口与指定的 Class 参数所表示的类或接口是否相同，或是否是其超类或超接口。</li>
<li>isInstance(Object obj) 判定指定的 Object 是否与此 Class 所表示的对象赋值兼容。</li>
<li>newInstance() 创建此 Class 对象所表示的类的一个新实例。</li>
</ul>
<p>####三、利用Class对象进行动态编程</p>
<p>#####动态建立类的新实例</p>
<p>######1. 通过 Class.newInstance 构建一个对象的新实例</p>
<pre><code>Date date = Date.class.newInstance();
System.out.println(date);
</code></pre><p>Class newInstance 要求这个类有默认的无参数构造器，如果没有默认构造器，就会抛出一个异常。</p>
<p>######2. 通过获取 Constructor，构造带参数的实例</p>
<pre><code>Constructor&lt;Integer&gt; constructor = Integer.class.getDeclaredConstructor(String.class);
Integer i =  constructor.newInstance(&quot;12&quot;);
System.out.println(i);
</code></pre><p>######3.动态获取Field的值</p>
<p>先创建一个普通的POJO对象。</p>
<pre><code>public class Person {

    private static int version = 1;

    private String name;

    private int age;

    private boolean sex;

    public Person(){};

    public Person(String name, int age, boolean sex){
        this.name = name;
        this.age = age;
        this.sex = sex;
    }

    public static void sayHi(Person p){
        System.out.println(&quot;hello, &quot; + p.getName());
    }

    public void introduceSelf(){
        System.out.println(&quot;Hi,I&apos;m &quot; + this.name);
    }

    ... //get set methods     
}
</code></pre><p>获取所有Field的值 </p>
<pre><code>public class ReflectField {

    public static void main(String[] args) throws IllegalArgumentException, IllegalAccessException {

        Person p = new Person(&quot;Jack&quot;,22,true);

        Field[] fields = Person.class.getDeclaredFields();

        for (Field field : fields) {
            // 如果没有访问权限，则设置访问权限
            if(!field.isAccessible()){
                field.setAccessible(true);
            }
            Object value = field.get(p);
            Class&lt;?&gt; fieldType = field.getType();

            System.out.println(&quot;field name=&quot; + field.getName()
                    + &quot;,type=&quot;+ fieldType.getName()
                    +  &quot;,value=&quot; + value);
        }    
    }    
}
</code></pre><p>######4.动态调用方法</p>
<p>使用的API:  Method对象的invoke方法<br>public Object invoke(Object obj, Object… args)  </p>
<ul>
<li>如果底层方法是静态的，那么可以忽略指定的 obj 参数。该参数可以为 null。   </li>
<li>如果底层方法所需的形参数为 0，则所提供的 args 数组长度可以为 0 或 null。   </li>
<li>返回值：如果方法正常完成，则将该方法返回的值返回给调用者；如果该值为基本类型，则首先适当地将其包装在对象中。但是，如果该值的类型为一组基本类型，则数组元素不 被包装在对象中；换句话说，将返回基本类型的数组。如果底层方法返回类型为 void，则该调用返回 null。 </li>
</ul>
<pre>
    public class MethodInvoker {

        public static void main(String[] args)throws Exception {

            Person jack = new Person("Jack",22,true);
            Person petter = new Person("Petter",22,true);

            // 调用类的静态方法
            Method staticMethod = Person.class.getMethod("sayHi", Person.class);
            staticMethod.invoke(null, jack);// 调用静态方法目标对象传null

            // 调用类的实例方法
            Method instanceMethod = Person.class.getMethod("introduceSelf", new Class<?>[]{});
            instanceMethod.invoke(petter, new Object[]{});

            // 调用泛型方法
            List<string> list = new ArrayList<string>();
            Method genericMethod = list.getClass().getMethod("add", Object.class);
            genericMethod.invoke(list, "hello");
            System.out.println(list.toString());
        }    
    }
</string></string></pre>

<p>由于泛型方法的实际类型在编译后被擦除，所以直接使用泛型容器的接口Map.class作为方法参数类型来作获取包含泛型参数的方法。</p>
<p>######5.动态创建数组</p>
<p>使用的API:</p>
<ul>
<li>Class.getComponentType() 来返回数组元素的类型</li>
<li><p>Array.newInstance(Class&lt;?&gt; componentType, int length)创建一个具有指定的组件类型和长度的新数组。<br><pre><br>  public class RefkectArray {</pre></p>
<pre><code>public static void main(String[] args) {
    Integer[] intArray = {1,2,3,4,5};
    Number[] numArray = copyOf(intArray, 3, Number[].class);
    System.out.println(Arrays.toString(numArray));
}
</code></pre></li>
</ul>
<pre><code>    // 来自 java.util.Arrays.copyOf
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) {

        T[] copy = ((Object)newType == (Object)Object[].class)
            ? (T[]) new Object[newLength]
            : (T[]) Array.newInstance(newType.getComponentType(), newLength);

        System.arraycopy(original, 0, copy, 0,
                         Math.min(original.length, newLength));
        return copy;
    }
}
</code></pre><p></p>
<p>####四、Method 对象的主要方法</p>
<ul>
<li>getAnnotation(Class&lt;A&gt; annotationClass) 如果存在该元素的指定类型的注释，则返回这些注释，否则返回 null。</li>
<li>getAnnotations() 返回此元素上存在的所有注释。</li>
<li>getGenericParameterTypes() 按照声明顺序返回 Type 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型的。</li>
<li>getGenericReturnType()  返回表示由此 Method 对象所表示方法的正式返回类型的 Type 对象。</li>
<li>getModifiers() 以整数形式返回此 Method 对象所表示方法的 Java 语言修饰符。</li>
<li>getParameterAnnotations() 返回表示按照声明顺序对此 Method 对象所表示方法的形参进行注释的那个数组的数组。</li>
<li>getParameterTypes() 按照声明顺序返回 Class 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型。</li>
<li>getReturnType() 返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型。</li>
<li>invoke(Object obj, Object… args) 对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。</li>
</ul>
<p><strong>Modifier</strong></p>
<p>Modifier 类提供了 static 方法和常量，对类和成员访问修饰符进行解码。Modifier.toString(int mod) 返回描述指定修饰符中的访问修饰符标志的字符串。</p>
<p>####五、利用反射读取一个类的完整信息（来自Core Java中的示例）</p>
<pre><code>// 源自Core Java中的 ReflectionTest
public class ReflectClass {

    public static void main(String[] args) throws Throwable {

        String name;

        if(args.length &gt;0){
            name = args[0];
        }else{
            Scanner in = new Scanner(System.in);
            System.out.println(&quot;Please enter the class name(e.g. java.lang.String):&quot;);
            name = in.next();
        }

        printClass(name);
    }

    private static void printClass(String className) throws Throwable{

        Class&lt;?&gt; clazz = Class.forName(className);

        String modifers = Modifier.toString(clazz.getModifiers());
        if(modifers.length() &gt; 0);
        System.out.print(modifers + &quot; &quot; + clazz.getName() + &quot; &quot;);

        Class&lt;?&gt;  superClasses = clazz.getSuperclass();
        if(superClasses != null &amp;&amp; !Object.class.equals(superClasses)){
            System.out.print(&quot;extends &quot; + superClasses.getName() + &quot; &quot;);
        }

        Class&lt;?&gt;[] interfaces =  clazz.getInterfaces();
        if(interfaces.length &gt; 0){
            System.out.print(&quot; implements &quot;);
            for(Class&lt;?&gt; interfacez : interfaces){
                System.out.print(interfacez.getName() + &quot;, &quot;);
            }
        }
        System.out.println();

        printFields(clazz);
        printConstructors(clazz);
        printMethods(clazz);
    }

    private static void printFields(Class&lt;?&gt; clazz){
        Field[] fields = clazz.getDeclaredFields();
        for(Field field : fields){

            String modifers = Modifier.toString(field.getModifiers());
            if(modifers.length() &gt; 0);
            System.out.print(modifers + &quot; &quot;);

            System.out.println(field.getType().getName() + &quot; &quot; + field.getName());
        }
    }

    private static void printConstructors(Class&lt;?&gt; clazz){

        Constructor&lt;?&gt;[] constructors = clazz.getConstructors();
        for(Constructor&lt;?&gt; constructor : constructors){

            String modifers = Modifier.toString(constructor.getModifiers());
            if(modifers.length() &gt; 0);
            System.out.print(modifers + &quot; &quot;);

            System.out.print(constructor.getName() + &quot;(&quot;);

            Class&lt;?&gt;[] parameterTypes = constructor.getParameterTypes();
            for(Class&lt;?&gt; parameterType : parameterTypes){
                System.out.print(parameterType.getName() + &quot;, &quot;);
            }
            System.out.println(&quot;)&quot;);
        }
    }

    private static void printMethods(Class&lt;?&gt; clazz){

        Method[] methods = clazz.getMethods();
        for(Method method : methods){

            String modifers = Modifier.toString(method.getModifiers());
            if(modifers.length() &gt; 0);
            System.out.print(modifers + &quot; &quot;);

            Class&lt;?&gt; returnType = method.getReturnType();
            System.out.print(returnType.getName() + &quot; &quot;);

            System.out.print(method.getName() + &quot;(&quot;);

            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();
            for(Class&lt;?&gt; parameterType : parameterTypes){
                System.out.print(parameterType.getName() + &quot;, &quot;);
            }
            System.out.println(&quot;)&quot;);
        }
    }
}
</code></pre><p>####六、Java中的类型体系</p>
<h5 id="Type-接口"><a href="#Type-接口" class="headerlink" title="Type 接口"></a>Type 接口</h5><p>位于java.lang.reflect 包内。Type 是 Java 编程语言中所有类型的公共高级接口。它们包括原始类型、参数化类型、数组类型、类型变量和基本类型。 </p>
<p><img src="/pics/java-type-interface-uml.jpg" alt=""></p>
<p>● Class 类是Type 的直接实现类，描述具体的类型。Class 类的实例表示正在运行的 Java 应用程序中的类和接口。枚举是一种类，注释是一种接口。每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也表示为 Class 对象。 </p>
<p>● ParameterizedType 表示参数化类型，如 Collection<string>。 </string></p>
<ol>
<li>getActualTypeArguments() 返回表示此类型实际类型参数的 Type 对象的数组。例如Map&lt;Long,String&gt; 将返回 java.lang.Long,java.lang.String.</li>
<li>getOwnerType() 返回 Type 对象，表示此类型是其成员之一的类型。</li>
<li>getRawType() 返回 Type 对象，表示声明此类型的类或接口。例如Map&lt;Long,String&gt; 将返回 Map.</li>
</ol>
<p>● TypeVariable 是各种类型变量的公共高级接口。描述类型变量（如 T extends Comparable&lt;? super &gt;）</p>
<ol>
<li>getBounds() 返回表示此类型变量上边界的 Type 对象的数组。</li>
<li>getGenericDeclaration() 返回 GenericDeclaration 对象，该对象表示声明此类型变量的一般声明。</li>
<li>getName() 返回此类型变量的名称，它出现在源代码中。</li>
</ol>
<p>● WildcardType 表示一个通配符类型表达式，如 ?、? extends Number 或 ? super Integer。 </p>
<ol>
<li>getLowerBounds() 返回表示此类型变量下边界的 Type 对象的数组。</li>
<li>getUpperBounds() 返回表示此类型变量上边界的 Type 对象的数组。</li>
</ol>
<p>● GenericArrayType 表示一种数组类型，其组件类型为参数化类型或类型变量。</p>
<ol>
<li>getGenericComponentType() 返回表示此数组的组件类型的 Type 对象。</li>
</ol>
<h4 id="Java-reflect-包的其它接口"><a href="#Java-reflect-包的其它接口" class="headerlink" title="Java reflect 包的其它接口"></a>Java reflect 包的其它接口</h4><p><img src="/pics/java-reflect-uml.jpg" alt=""></p>
<p>● InvocationHandler 是代理实例的调用处理程序 实现的接口。</p>
<p>Object invoke(Object proxy, Method method, Object[] args) 在代理实例上处理方法调用并返回结果。 </p>
<p>● AnnotatedElement表示目前正在此 VM 中运行的程序的一个已注释元素。该接口允许反射性地读取注释。</p>
<p>● AccessibleObject 类是 Field、Method 和 Constructor 对象的基类。它提供了将反射的对象标记为在使用时取消默认 Java 语言访问控制检查的能力。对于公共成员、默认（打包）访问成员、受保护成员和私有成员，在分别使用 Field、Method 或 Constructor 对象来设置或获取字段、调用方法，或者创建和初始化类的新实例的时候，会执行访问检查。 </p>
<p>● Member成员是一种接口，反映有关单个成员（字段或方法）或构造方法的标识信息。 </p>
<p>● GenericDeclaration声明类型变量的所有实体的公共接口。</p>
<p>TypeVariable&lt;?&gt;[] getTypeParameters()  返回声明顺序的 TypeVariable 对象的数组，这些对象表示由此 GenericDeclaration 对象表示的一般声明声明的类型变量。 </p>
<p>####七、通过反射获取运行时的泛型参数</p>
<h5 id="1-通过反射获取运行时泛型类的实际泛型参数"><a href="#1-通过反射获取运行时泛型类的实际泛型参数" class="headerlink" title="1. 通过反射获取运行时泛型类的实际泛型参数"></a>1. 通过反射获取运行时泛型类的实际泛型参数</h5><p>使用API： this.getClass().getGenericSuperclass()</p>
<pre><code>class  BaseDAO&lt;T&gt;{

    @SuppressWarnings(&quot;unchecked&quot;)
    public void save(T obj){
        Type type = this.getClass().getGenericSuperclass();
        if(type instanceof ParameterizedType){
            Type[] actualTypes  =((ParameterizedType)type).getActualTypeArguments();
            System.out.println(&quot;save type &quot; + actualTypes[0]);
            System.out.println(&quot;save class &quot; + (Class&lt;T&gt;)actualTypes[0]);
            System.out.println(&quot;get by obj &quot; + obj.getClass());

        }
    }
}

class PersonDAO extends BaseDAO&lt;Person&gt;{}

public static void main(String[] args) throws Exception {
    PersonDAO personDao = new PersonDAO();
    personDao.save(new Person());
}
</code></pre><p>其中，通过 this.getClass().getGenericSuperclass()获取当前正在运行对象超类的泛型类型，如果超类是个参数化类型，那么获取该参数化类型的实际类型信息。</p>
<h5 id="2-通过反射获取泛型方法的实际参数类型"><a href="#2-通过反射获取泛型方法的实际参数类型" class="headerlink" title="2. 通过反射获取泛型方法的实际参数类型"></a>2. 通过反射获取泛型方法的实际参数类型</h5><p>使用API：method.getGenericParameterTypes()</p>
<pre><code>public class ReflectGeneric {

    static class  BaseDAO&lt;T&gt;{

        @SuppressWarnings(&quot;unchecked&quot;)
        public void save(T obj){
            Type type = this.getClass().getGenericSuperclass();
            if(type instanceof ParameterizedType){
                Type[] actualTypes  =((ParameterizedType)type).getActualTypeArguments();
                System.out.println(&quot;save type &quot; + actualTypes[0]);
                System.out.println(&quot;save class &quot; + (Class&lt;T&gt;)actualTypes[0]);
                System.out.println(&quot;get by obj &quot; + obj.getClass());

            }
        }

        // 只做示例：没有返回值 
        public void findByIds(Map&lt;Long, String&gt; IdUserIdMap){}

        public void findByIds(Long[] ids){}

        public void findByIds(T[] objArray){}

    }

    static class PersonDAO extends BaseDAO&lt;Person&gt;{

    }

    public static void main(String[] args) throws Exception {

        PersonDAO personDao = new PersonDAO();
        personDao.save(new Person());

        Method method = PersonDAO.class.getMethod(&quot;findByIds&quot;, Map.class);
        printGenericParameterTypes(method);

        Method[] methods = BaseDAO.class.getDeclaredMethods();
        for(Method item : methods){
            printGenericParameterTypes(item);
        }
    }

    private static void printGenericParameterTypes(Method method) {

        String modifers = Modifier.toString(method.getModifiers());
        if(modifers.length() &gt; 0);
        System.out.print(modifers + &quot; &quot;);

        System.out.print(method.getName() + &quot;(&quot;);
        Type[] genericParameterTypes  = method.getGenericParameterTypes();
        for(Type parameterType : genericParameterTypes){
            printType(parameterType );
            System.out.print(&quot;,&quot;);
        }
        System.out.println(&quot;)&quot;);
    }

    private static void printType(Type parameterType) {

        if(parameterType instanceof Class){
            System.out.print(((Class&lt;?&gt;)parameterType).getName());

        }else if(parameterType instanceof ParameterizedType){
            ParameterizedType type = (ParameterizedType)parameterType;

            System.out.print(((Class&lt;?&gt;)type.getRawType()).getName()   + &quot;&lt;&quot;);
            Type[] types  = ((ParameterizedType) parameterType).getActualTypeArguments();
            for(Type type2 : types){
                System.out.print(((Class&lt;?&gt;)type2).getName() + &quot;,&quot;);
            }
            System.out.print(&quot;&gt; &quot;);

        }else if(parameterType instanceof GenericArrayType){

            GenericArrayType type = (GenericArrayType)parameterType;
            System.out.print(type.getGenericComponentType() + &quot;[] &quot;);

        }else if(parameterType instanceof TypeVariable){
            System.out.print(((TypeVariable&lt;?&gt;) parameterType).getName());

        }else if(parameterType instanceof WildcardType){

            WildcardType wildType = (WildcardType)parameterType;
            if(wildType.getUpperBounds().length &gt; 0){
                System.out.print(&quot;? extends &quot; + Arrays.toString(wildType.getUpperBounds()));
            }else if(wildType.getLowerBounds().length &gt; 0){
                System.out.print(&quot;? super &quot; + Arrays.toString(wildType.getLowerBounds()));
            }
        }
    }
}
</code></pre><p>以上的示例代码只对类型做简单的判断，没有判断多层级的类型嵌套，完整的示例请参考 《Java核心技术》中的12.9.2 章节中的示例代码。</p>
<p>参考资料</p>
<ul>
<li>JDK文档</li>
<li>《Java核心技术》</li>
<li>《Java Reflection in Action》</li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-dyn0603/" target="_blank" rel="noopener">Java编程 的动态性，第 2部分: 引入反射</a></li>
<li><a href="http://docs.oracle.com/javase/tutorial/reflect/index.html" target="_blank" rel="noopener">The Reflection API</a></li>
<li><a href="http://www.blogjava.net/jialing/archive/2006/08/24/JavaReflectionCookbook1.html" target="_blank" rel="noopener">Java反射经典实例 Java Reflection Cookbook (初级)</a></li>
<li><a href="http://www.blogjava.net/fancydeepin/archive/2012/08/25/java_generics.html" target="_blank" rel="noopener">java 泛型 深入</a> </li>
<li><a href="http://lavasoft.blog.51cto.com/62575/43218/" target="_blank" rel="noopener">Java 反射机制深入研究</a></li>
</ul>

      
    </div>
    <footer class="article-footer2">
      <div id="footer-info" class="inner">
        <a href="http://www.618shoe.com/">莆田1:1精仿鞋微信号</a>
        <a href="http://www.618shoe.com/">莆田高仿鞋子的价格表</a>
        <a href="http://www.618shoe.com/">关于莆田仿鞋</a>
        <a href="http://www.618shoe.com/">莆田高仿鞋淘宝店店名</a>
        <a href="http://www.618shoe.com/">莆田精仿鞋官网</a>
         咨询QQ：<a title="点击这里给我发消息" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2727291807&amp;site=www.cactussoft.cn&amp;menu=yes" target="_blank"><img src="http://wpa.qq.com/pa?p=2:2727291807:41"></a>
      </div>
        <div id="footer-info" class="inner">
          <a href="http://www.618shoe.com/">莆田高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">1：1高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">高仿鞋批发市场</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">高仿鞋网</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">广州高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">外贸尾单鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">精仿鞋专线</a>&nbsp;&nbsp;
      </div>
      <div id="footer-info" class="inner">
             <a href="http://www.618shoe.com/">莆田高仿鞋批发</a>&nbsp;&nbsp;
             公司网站:&nbsp;&nbsp;<a href="http://www.618shoe.com//" target="_blank">http://www.618shoe.com/</a>&nbsp;&nbsp;
             <a href="http://www.618shoe.com/">高仿鞋批发市场</a>
             微信 <img src="/pics/qrcode.jpg" style="width:100px;height:100px;">
      </div>
    </footer>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2012/12/08/java-reflection/" data-id="cja9q2acc000vnh5ikomzz93u" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-thrift-quick-start" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2012/12/07/thrift-quick-start/" class="article-date">
  <time datetime="2012-12-07T12:34:00.000Z" itemprop="datePublished">2012-12-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/thrift/">thrift</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/12/07/thrift-quick-start/">thrift 快速入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>####一、简介 </p>
<p>thrift 是facebook 开源的跨语言、可扩展的RPC框架，实现了完整的软件栈，包括利用生成代码的引擎来构建高效的服务，支持C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, OCaml , Delphi 等语言。</p>
<p>thrift 类似ICE、Protobuf 等框架，使用后缀名为.thrift 的 <strong>接口定义</strong>（interface definition）文件来定义thrift 的数据结构与服务接口。定义的服务接口由服务端实现，可以被客户端所调用。可以根据你所使用的语言，生成相应的代码文件。使用如下命令生成：</p>
<pre><code>thrift --gen &lt;language&gt; &lt;Thrift filename&gt;
</code></pre><p>####二、thrift 架构</p>
<p>thrift = RPC + Serialization，类似于Java的Hession 或RMI，不过thrift支持跨语言。<br>根据接口定义文件，可以根据不同的语言生成不同的的基础代码，来快速构建跨语言的分布式服务。</p>
<p><img src="/pics/thrift_stack.png" alt=""></p>
<p>thrift 层次</p>
<ol>
<li>Your Code: 你的业务代码，具体服务实现的业务逻辑</li>
<li>FooService.Client/ FooService.Processor: 是thrift 生成的代码，我们通过访问生成的Client来实现远程RPC调用，通过实现 定义中的接口，而成为一个Processor 的具体处理类。</li>
<li>Foo.write()/read(): 根据定义的结构体来向协议层TProtocol 读出或写入数据，相当于实现 对象的序列化与反序列化。</li>
<li>TProtocol：传输协议层</li>
<li>TTransport: 传输层</li>
<li>Underlying I/O: 底层IO</li>
</ol>
<p>引用官方的层次图 <a href="http://thrift.apache.org/docs/concepts/" target="_blank" rel="noopener">http://thrift.apache.org/docs/concepts/</a></p>
<pre>
      +-------------------------------------------+
      | Server                                    |
      | (single-threaded, event-driven etc)       |
      +-------------------------------------------+
      | Processor                                 |
      | (compiler generated)                      |
      +-------------------------------------------+
      | Protocol                                  |
      | (JSON, compact etc)                       |
      +-------------------------------------------+
      | Transport                                 |
      | (raw TCP, HTTP etc)                       |
      +-------------------------------------------+
</pre>

<p>#####Transport</p>
<p>TTransport层提供对网络IO读取或写入的简单封装，能够让thrift 与系统其它部分解耦。<br><strong>Transport 的接口</strong></p>
<ul>
<li>open</li>
<li>close</li>
<li>read</li>
<li>write</li>
<li>flush</li>
</ul>
<p>在Transport 的基础上，thrift 在服务端使用ServerTransport为新建立的连接创建原始传输对象。</p>
<p><strong>ServerTransport的接口</strong></p>
<ul>
<li>open</li>
<li>listen</li>
<li>accept</li>
<li>close</li>
</ul>
<p>传输层的类型</p>
<ul>
<li>TSocket- 使用堵塞式I/O进行传输，也是最常见的模式。</li>
<li>TFramedTransport- 使用非阻塞方式，按块的大小，进行传输，类似于Java中的NIO。</li>
<li>TFileTransport- 顾名思义按照文件的方式进程传输，虽然这种方式不提供Java的实现，但是实现起来非常简单。</li>
<li>TMemoryTransport- 使用内存I/O，就好比Java中的ByteArrayOutputStream实现。</li>
<li>TZlibTransport- 使用执行zlib压缩，不提供Java的实现。</li>
</ul>
<p>#####Protocol</p>
<p>TProtocol传输协议用来指定数据序列化的格式，例如JSON，XML或是压缩的二进流等。<br><strong>TProtocol接口定义</strong>：</p>
<pre><code>writeMessageBegin(name, type, seq)
writeMessageEnd()
writeStructBegin(name)
writeStructEnd()
writeFieldBegin(name, type, id)
writeFieldEnd()
writeFieldStop()
writeMapBegin(ktype, vtype, size)
writeMapEnd()
writeListBegin(etype, size)
writeListEnd()
writeSetBegin(etype, size)
writeSetEnd()
writeBool(bool)
writeByte(byte)
writeI16(i16)
writeI32(i32)
writeI64(i64)
writeDouble(double)
writeString(string)

name, type, seq = readMessageBegin()
                  readMessageEnd()
name = readStructBegin()
       readStructEnd()
name, type, id = readFieldBegin()
                 readFieldEnd()
k, v, size = readMapBegin()
             readMapEnd()
etype, size = readListBegin()
              readListEnd()
etype, size = readSetBegin()
              readSetEnd()
bool = readBool()
byte = readByte()
i16 = readI16()
i32 = readI32()
i64 = readI64()
double = readDouble()
string = readString()
</code></pre><p>传输协议的类型：</p>
<ul>
<li>TBinaryProtocol – 二进制编码格式进行数据传输。</li>
<li>TCompactProtocol – 这种协议非常有效的，使用Variable-Length Quantity (VLQ) 编码对数据进行压缩。</li>
<li>TJSONProtocol – 使用JSON的数据编码协议进行数据传输。</li>
<li>TSimpleJSONProtocol – 这种节约只提供JSON只写的协议，适用于通过脚本语言解析</li>
<li>TDebugProtocol – 在开发的过程中帮助开发人员调试用的，以文本的形式展现方便阅读。</li>
</ul>
<p>#####Scheme</p>
<p>Scheme 实现序列化、反序列化的接口中。每个Thrift对象（包括输入参数、返回值）都实现该方法，从而达到序列化到指定的协议中去，或者从指定的协议中读出对象。</p>
<pre><code>public interface IScheme&lt;T extends TBase&gt; {

  public void read(org.apache.thrift.protocol.TProtocol iproto, T struct) throws org.apache.thrift.TException;

  public void write(org.apache.thrift.protocol.TProtocol oproto, T struct) throws org.apache.thrift.TException;

}    

public interface SchemeFactory {    
  public &lt;S extends IScheme&gt; S getScheme();    
}

public abstract class StandardScheme&lt;T extends TBase&gt; implements IScheme&lt;T&gt; {

}
</code></pre><p>#####Processor</p>
<p>Processor 用来服务端收到请求后，对传入的数据进行读取后，再写入到输出中。具体就是在服务端收到数据包后，根据输入协议TProtocol in 读取相应请求的方法和参数，调用具体实现服务的业务逻辑后，再将返回的结果写入TProtocol out中。</p>
<pre><code>interface TProcessor {
    bool process(TProtocol in, TProtocol out) throws TException
}
</code></pre><p>Processor 由代码生成器根据不同的语言环境生成。</p>
<p>#####Server 服务端</p>
<p>Server的处理流程如下</p>
<ul>
<li>创建一个服务端的传输transport</li>
<li>创建用来输入和输出的transport </li>
<li>创建基于传输协议protocol 上的processor(代理到相应的业务方法)</li>
<li>等待客户端连接，并把请求转发给processor </li>
</ul>
<p>服务端类型</p>
<ul>
<li>TSimpleServer  单线程服务器端使用标准的堵塞式I/O。</li>
<li>TThreadPoolServer  多线程服务器端使用标准的堵塞式I/O。</li>
<li>TNonblockingServer – 多线程服务器端使用非堵塞式I/O，并且实现了Java中的NIO通道。</li>
<li>THsHaServer -（半同步/半异步的server）就应运而生了。它使用一个单独的线程来处理网络I/O，一个独立的worker线程池来处理消息。</li>
<li>TThreadedSelectorServer允许你用多个线程来处理网络I/O。它维护了两个线程池，一个用来处理网络I/O，另一个用来进行请求的处理。</li>
</ul>
<h4 id="三、利用thrift文件生成java环境的文件"><a href="#三、利用thrift文件生成java环境的文件" class="headerlink" title="三、利用thrift文件生成java环境的文件"></a>三、利用thrift文件生成java环境的文件</h4><p>thrift服务接口定义文件</p>
<pre><code>// usage
// for java:
// cd ${project_path}
// thrift -gen java -out ./src/main/java ./src/main/thrift/user.thrift

namespace java com.cjf.practice // 指定生成java 文件的包名
namespace py com.cjf.practice

const string VERSION = &quot;1.0.0&quot; // 定义一个常量（非必须）

// 定义一个结构体，相当于Java中的领域对象
struct UserProfile {
    1: i32 uid,
    2: string name,
    3: string blurb
}

// 定义服务接口
service UserStorage {
    void store(1: UserProfile user),
    UserProfile retrieve(1: i32 uid)
}
</code></pre><p>接口定义文件具体支持的类型与结构，请参考官网  <a href="http://thrift.apache.org/docs/idl/" target="_blank" rel="noopener">Thrift interface description language</a>。</p>
<p>生成UserProfile.java 文件类似Protobuf 生成的对象文件。</p>
<pre><code>public class UserProfile implements org.apache.thrift.TBase&lt;UserProfile, UserProfile._Fields&gt;, java.io.Serializable, Cloneable {
  private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct(&quot;UserProfile&quot;);

  private static final org.apache.thrift.protocol.TField UID_FIELD_DESC = new org.apache.thrift.protocol.TField(&quot;uid&quot;, org.apache.thrift.protocol.TType.I32, (short)1);
  private static final org.apache.thrift.protocol.TField NAME_FIELD_DESC = new org.apache.thrift.protocol.TField(&quot;name&quot;, org.apache.thrift.protocol.TType.STRING, (short)2);
  private static final org.apache.thrift.protocol.TField BLURB_FIELD_DESC = new org.apache.thrift.protocol.TField(&quot;blurb&quot;, org.apache.thrift.protocol.TType.STRING, (short)3);

  private static final Map&lt;Class&lt;? extends IScheme&gt;, SchemeFactory&gt; schemes = new HashMap&lt;Class&lt;? extends IScheme&gt;, SchemeFactory&gt;();
  static {
    schemes.put(StandardScheme.class, new UserProfileStandardSchemeFactory());
    schemes.put(TupleScheme.class, new UserProfileTupleSchemeFactory());
  }

  public int uid; // required
  public String name; // required
  public String blurb; // required

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements org.apache.thrift.TFieldIdEnum {
    UID((short)1, &quot;uid&quot;),
    NAME((short)2, &quot;name&quot;),
    BLURB((short)3, &quot;blurb&quot;);

    private static final Map&lt;String, _Fields&gt; byName = new HashMap&lt;String, _Fields&gt;();

    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }

    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 1: // UID
          return UID;
        case 2: // NAME
          return NAME;
        case 3: // BLURB
          return BLURB;
        default:
          return null;
      }
    }
    ...
</code></pre><p>生成的服务接口文件UserStorage：</p>
<p>######1. 第1部分是服务接口的定义：<br>    public class UserStorage {</p>
<pre><code>public interface Iface {

  public void store(UserProfile user) throws org.apache.thrift.TException;

  public UserProfile retrieve(int uid) throws org.apache.thrift.TException;

}

public interface AsyncIface {

  public void store(UserProfile user, org.apache.thrift.async.AsyncMethodCallback&lt;AsyncClient.store_call&gt; resultHandler) throws org.apache.thrift.TException;

  public void retrieve(int uid, org.apache.thrift.async.AsyncMethodCallback&lt;AsyncClient.retrieve_call&gt; resultHandler) throws org.apache.thrift.TException;

}
</code></pre><p>######2. 第2部分同步和异步接口的Client实现：<br>    public static class Client extends org.apache.thrift.TServiceClient implements Iface {<br>        public static class Factory implements org.apache.thrift.TServiceClientFactory<client> {<br>          public Factory() {}<br>          public Client getClient(org.apache.thrift.protocol.TProtocol prot) {<br>            return new Client(prot);<br>          }<br>          public Client getClient(org.apache.thrift.protocol.TProtocol iprot, org.apache.thrift.protocol.TProtocol oprot) {<br>            return new Client(iprot, oprot);<br>          }<br>        }<br>        ….</client></p>
<pre><code>public static class AsyncClient extends org.apache.thrift.async.TAsyncClient implements AsyncIface {
  public static class Factory implements org.apache.thrift.async.TAsyncClientFactory&lt;AsyncClient&gt; {
    private org.apache.thrift.async.TAsyncClientManager clientManager;
    private org.apache.thrift.protocol.TProtocolFactory protocolFactory;
    public Factory(org.apache.thrift.async.TAsyncClientManager clientManager, org.apache.thrift.protocol.TProtocolFactory protocolFactory) {
      this.clientManager = clientManager;
      this.protocolFactory = protocolFactory;
    }
    public AsyncClient getAsyncClient(org.apache.thrift.transport.TNonblockingTransport transport) {
      return new AsyncClient(protocolFactory, clientManager, transport);
    }
  }
</code></pre><p>######3. 第3部分就是生成Processor：</p>
<pre><code>public static class Processor&lt;I extends Iface&gt; extends org.apache.thrift.TBaseProcessor&lt;I&gt; implements org.apache.thrift.TProcessor {
  private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class.getName());
  public Processor(I iface) {
    super(iface, getProcessMap(new HashMap&lt;String, org.apache.thrift.ProcessFunction&lt;I, ? extends org.apache.thrift.TBase&gt;&gt;()));
  }

  protected Processor(I iface, Map&lt;String,  org.apache.thrift.ProcessFunction&lt;I, ? extends  org.apache.thrift.TBase&gt;&gt; processMap) {
    super(iface, getProcessMap(processMap));
  }
</code></pre><p>可以看到Processor需要传入Iface接口的实现作为构造函数的参数，并且继承于TBaseProcessor类。</p>
<pre><code>private static &lt;I extends Iface&gt; Map&lt;String,  org.apache.thrift.ProcessFunction&lt;I, ? extends  org.apache.thrift.TBase&gt;&gt; getProcessMap(Map&lt;String,  org.apache.thrift.ProcessFunction&lt;I, ? extends  org.apache.thrift.TBase&gt;&gt; processMap) {
  processMap.put(&quot;store&quot;, new store());
  processMap.put(&quot;retrieve&quot;, new retrieve());
  return processMap;
}
</code></pre><p>这里的processMap就是具体的业务方法对象，每个业务方法都是一个ProcessFunction对象，会被TBaseProcessor中被调用。TBaseProcessor是所有生成的所有Processor 的父类。<br>在TBaseProcessor中，我们可以看到Processor的处理流程。</p>
<pre><code>@Override
public boolean process(TProtocol in, TProtocol out) throws TException {
  TMessage msg = in.readMessageBegin();
  // 根据msg.name 获取相应的ProcessFunction
  ProcessFunction fn = processMap.get(msg.name);
  if (fn == null) {
    TProtocolUtil.skip(in, TType.STRUCT);
    in.readMessageEnd();
    TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, &quot;Invalid method name: &apos;&quot;+msg.name+&quot;&apos;&quot;);
    out.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
    x.write(out);
    out.writeMessageEnd();
    out.getTransport().flush();
    return true;
  }
  fn.process(msg.seqid, in, out, iface);
  return true;
}
</code></pre><h4 id="四、实现完整的示例（服务端和客户端均采用阻塞IO传输的Transport）"><a href="#四、实现完整的示例（服务端和客户端均采用阻塞IO传输的Transport）" class="headerlink" title="四、实现完整的示例（服务端和客户端均采用阻塞IO传输的Transport）"></a>四、实现完整的示例（服务端和客户端均采用阻塞IO传输的Transport）</h4><h6 id="服务实现类"><a href="#服务实现类" class="headerlink" title="服务实现类"></a>服务实现类</h6><pre><code>public class UserStorageServiceImpl implements Iface{

    private static Map&lt;Integer, UserProfile&gt; userMap = new HashMap&lt;Integer, UserProfile&gt;();

    @Override
    public void store(UserProfile user) throws TException {
        userMap.put(user.getUid(), user);
    }

    @Override
    public UserProfile retrieve(int uid) throws TException {
        return userMap.get(uid);
    }

}
</code></pre><h6 id="创建一个阻塞式（Blocking）Socket的多线程的Server"><a href="#创建一个阻塞式（Blocking）Socket的多线程的Server" class="headerlink" title="创建一个阻塞式（Blocking）Socket的多线程的Server"></a>创建一个阻塞式（Blocking）Socket的多线程的Server</h6><pre><code>public class SyncUserStorageServer {

    public static void main(String[] args) throws TTransportException {
        int port = 8600;

        TServerSocket serverTransport = new TServerSocket(port);
        Factory portFactory = new TBinaryProtocol.Factory(true, true);
        TProcessor processor = new UserStorage.Processor&lt;UserStorageServiceImpl&gt;(new UserStorageServiceImpl());

        TThreadPoolServer.Args serverArgs = new TThreadPoolServer.Args(serverTransport);
        serverArgs.processor(processor);
        serverArgs.protocolFactory(portFactory);

        TThreadPoolServer server = new TThreadPoolServer(serverArgs);
        server.serve();
    }

}
</code></pre><h6 id="客户端的同步调用代码"><a href="#客户端的同步调用代码" class="headerlink" title="客户端的同步调用代码"></a>客户端的同步调用代码</h6><pre><code>public class UserStorageClient {

    public static void main(String[] args) throws TException, IOException {

        TTransport transport = new TSocket(&quot;localhost&quot;, 8600);
        TBinaryProtocol binaryProtocol = new TBinaryProtocol(transport);
        UserStorage.Client client = new UserStorage.Client.Factory().getClient(binaryProtocol);

        UserProfile user = new UserProfile(1, &quot;user_name&quot;, &quot;sth... i don&apos;t know&quot;);

        transport.open();

        System.out.println(user);
        client.store(user);
        System.out.println(&quot;store finished.&quot;);

        UserProfile fetchUser = client.retrieve(user.getUid());
        System.out.println(fetchUser);
        System.out.println(user.equals(fetchUser));

        transport.close();

    }
}
</code></pre><h4 id="五、服务端采用非阻塞式（Non-Blocking）传输的transport"><a href="#五、服务端采用非阻塞式（Non-Blocking）传输的transport" class="headerlink" title="五、服务端采用非阻塞式（Non-Blocking）传输的transport"></a>五、服务端采用非阻塞式（Non-Blocking）传输的transport</h4><p>######服务端</p>
<pre><code>public class AsyncUserStorageServer {

    public static void main(String[] args) throws TTransportException {
        int port = 8600;

        TNonblockingServerSocket serverTransport = new TNonblockingServerSocket(port);
        Factory portFactory = new TBinaryProtocol.Factory(true, true);
        TProcessor processor = new UserStorage.Processor&lt;UserStorageServiceImpl&gt;(new UserStorageServiceImpl());

        TThreadedSelectorServer.Args serverArgs = new TThreadedSelectorServer.Args(serverTransport);
        serverArgs.processor(processor);
        serverArgs.protocolFactory(portFactory);

        TThreadedSelectorServer server = new TThreadedSelectorServer(serverArgs);
        server.serve();
    }
}
</code></pre><h6 id="异步调用的客户端-异步调用必须采用非阻塞式传输TNonblockingTransport"><a href="#异步调用的客户端-异步调用必须采用非阻塞式传输TNonblockingTransport" class="headerlink" title="异步调用的客户端(异步调用必须采用非阻塞式传输TNonblockingTransport)"></a>异步调用的客户端(异步调用必须采用非阻塞式传输TNonblockingTransport)</h6><pre><code>public class AsyncUserStorageClient {


    static final CountDownLatch countDownLatch = new CountDownLatch(1);

    public static void main(String[] args) throws TException, IOException, InterruptedException {


        TNonblockingTransport transport = new TNonblockingSocket(&quot;localhost&quot;, 8600);
        TAsyncClientManager clientManager = new TAsyncClientManager();

        TProtocolFactory protocolFactory = new TBinaryProtocol.Factory();
        final UserStorage.AsyncClient client = new UserStorage.AsyncClient.Factory(clientManager, protocolFactory)
                                        .getAsyncClient(transport);

        final UserProfile user = new UserProfile(1, &quot;user_name&quot;, &quot;sth... i don&apos;t know&quot;);

        System.out.println(user);
        client.store(user, new AsyncMethodCallback&lt;UserStorage.AsyncClient.store_call&gt;() {

            @Override
            public void onError(Exception exception) {
                System.out.println(exception.getMessage());

                countDownLatch.countDown();
            }

            @Override
            public void onComplete(store_call response) {
                // TODO Auto-generated method stub
                try {
                    System.out.println(&quot;store finished.&quot;);
                    step2(client, user);
                } catch (TException e) {
                    e.printStackTrace();
                }
            }
        });


        countDownLatch.await();

    }

    private static void step2(UserStorage.AsyncClient client, final UserProfile user) throws TException {

        client.retrieve(user.getUid(), new AsyncMethodCallback&lt;UserStorage.AsyncClient.retrieve_call&gt;() {

            @Override
            public void onError(Exception exception) {
                // TODO Auto-generated method stub
                countDownLatch.countDown();
            }

            @Override
            public void onComplete(retrieve_call response) {
                try {
                    UserProfile fetchUser = response.getResult();
                    System.out.println(fetchUser);
                    System.out.println(user.equals(fetchUser));
                } catch (TException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }

                countDownLatch.countDown();

            }
        });
    }
</code></pre><h6 id="同步调用，但采用带缓存的网络IO（TFramedTransport）的客户端"><a href="#同步调用，但采用带缓存的网络IO（TFramedTransport）的客户端" class="headerlink" title="同步调用，但采用带缓存的网络IO（TFramedTransport）的客户端"></a>同步调用，但采用带缓存的网络IO（TFramedTransport）的客户端</h6><pre><code>public class SyncUserStorageClientForAsyncServer {

    public static void main(String[] args) throws TException, IOException {

        TTransport transport = new TFramedTransport(new TSocket(&quot;localhost&quot;, 8600));
        TBinaryProtocol binaryProtocol = new TBinaryProtocol(transport);
        UserStorage.Client client = new UserStorage.Client.Factory().getClient(binaryProtocol);

        transport.open();

        UserProfile user = new UserProfile(1, &quot;user_name&quot;, &quot;sth... i don&apos;t know&quot;);
        System.out.println(user);
        client.store(user);
        System.out.println(&quot;store finished.&quot;);

        UserProfile fetchUser = client.retrieve(user.getUid());
        System.out.println(fetchUser);
        System.out.println(user.equals(fetchUser));

        transport.close();
    }

}
</code></pre><h4 id="六、服务端采用带缓存的TFramedTransport传输"><a href="#六、服务端采用带缓存的TFramedTransport传输" class="headerlink" title="六、服务端采用带缓存的TFramedTransport传输"></a>六、服务端采用带缓存的TFramedTransport传输</h4><pre><code>public class FramedUserStorageServer {

    public static void main(String[] args) throws TTransportException {
        int port = 8600;

        TServerTransport serverTransport = new TServerSocket(port);
        Factory portFactory = new TBinaryProtocol.Factory(true, true);
        TProcessor processor = new UserStorage.Processor&lt;UserStorageServiceImpl&gt;(new UserStorageServiceImpl());

        TThreadPoolServer.Args serverArgs = new TThreadPoolServer.Args(serverTransport);
        serverArgs.processor(processor);
        serverArgs.protocolFactory(portFactory);
        serverArgs.transportFactory(new TFramedTransport.Factory());

        TThreadPoolServer server = new TThreadPoolServer(serverArgs);
        server.serve();
    }

}
</code></pre><h6 id="相应的同步调用客户"><a href="#相应的同步调用客户" class="headerlink" title="相应的同步调用客户"></a>相应的同步调用客户</h6><pre><code>public class SyncUserStorageClientForAsyncServer {

    public static void main(String[] args) throws TException, IOException {

        TTransport transport = new TFramedTransport(new TSocket(&quot;localhost&quot;, 8600));
        TBinaryProtocol binaryProtocol = new TBinaryProtocol(transport);
        UserStorage.Client client = new UserStorage.Client.Factory().getClient(binaryProtocol);

        transport.open();

        UserProfile user = new UserProfile(1, &quot;user_name&quot;, &quot;sth... i don&apos;t know&quot;);
        System.out.println(user);
        client.store(user);
        System.out.println(&quot;store finished.&quot;);

        UserProfile fetchUser = client.retrieve(user.getUid());
        System.out.println(fetchUser);
        System.out.println(user.equals(fetchUser));

        transport.close();
    }

}
</code></pre><h6 id="可以支持异步调用的客户端。"><a href="#可以支持异步调用的客户端。" class="headerlink" title="可以支持异步调用的客户端。"></a>可以支持异步调用的客户端。</h6><p>小结：服务端网络传输有三种模式：BLOCKING, FRAMED, NONBLOCKING;服务端与客户端采用的transport 与协议要一致；客户端是否异步调用与服务端是否异步网络IO无关。</p>
<p>例子源码： <a href="https://github.com/sharewind/thrift-quick-start" target="_blank" rel="noopener">https://github.com/sharewind/thrift-quick-start</a></p>
<p>参考资料</p>
<ul>
<li>thrift官方站点 <a href="http://thrift.apache.org/" target="_blank" rel="noopener">http://thrift.apache.org/</a></li>
<li>Apache Thrift Features <a href="http://thrift.apache.org/docs/features/" target="_blank" rel="noopener">http://thrift.apache.org/docs/features/</a></li>
<li>thrift 安装指南 <a href="http://thrift.apache.org/docs/install/" target="_blank" rel="noopener">Installation Tutorials</a></li>
<li>Apache Thrift (<strong>一篇详细介绍thrift的文章</strong>) <a href="http://jnb.ociweb.com/jnb/jnbJun2009.html" target="_blank" rel="noopener">http://jnb.ociweb.com/jnb/jnbJun2009.html</a></li>
<li>Apache Thrift入门1-架构&amp;介绍 <a href="http://www.javabloger.com/article/apache-thrift-architecture.html" target="_blank" rel="noopener">http://www.javabloger.com/article/apache-thrift-architecture.html</a></li>
<li>Apache Thrift - 可伸缩的跨语言服务开发框架 <a href="http://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/index.html" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/index.html</a></li>
<li>Java版的各种Thrift server实现的比较 <a href="http://www.codelast.com/?p=4824" target="_blank" rel="noopener">http://www.codelast.com/?p=4824</a></li>
<li>twitter开源的ThriftConnectionFactory <a href="https://github.com/twitter/commons/blob/master/src/java/com/twitter/common/thrift/ThriftConnectionFactory.java" target="_blank" rel="noopener">https://github.com/twitter/commons/blob/master/src/java/com/twitter/common/thrift/ThriftConnectionFactory.java</a></li>
<li>Thrift and Protocol Buffers performance in Java <a href="http://timyang.net/programming/thrift-protocol-buffers-performance-java/" target="_blank" rel="noopener">http://timyang.net/programming/thrift-protocol-buffers-performance-java/</a></li>
<li>Java 跨语言实现方案 <a href="http://rdc.taobao.com/team/jm/archives/389" target="_blank" rel="noopener">http://rdc.taobao.com/team/jm/archives/389</a></li>
</ul>

      
    </div>
    <footer class="article-footer2">
      <div id="footer-info" class="inner">
        <a href="http://www.618shoe.com/">莆田1:1精仿鞋微信号</a>
        <a href="http://www.618shoe.com/">莆田高仿鞋子的价格表</a>
        <a href="http://www.618shoe.com/">关于莆田仿鞋</a>
        <a href="http://www.618shoe.com/">莆田高仿鞋淘宝店店名</a>
        <a href="http://www.618shoe.com/">莆田精仿鞋官网</a>
         咨询QQ：<a title="点击这里给我发消息" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2727291807&amp;site=www.cactussoft.cn&amp;menu=yes" target="_blank"><img src="http://wpa.qq.com/pa?p=2:2727291807:41"></a>
      </div>
        <div id="footer-info" class="inner">
          <a href="http://www.618shoe.com/">莆田高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">1：1高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">高仿鞋批发市场</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">高仿鞋网</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">广州高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">外贸尾单鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">精仿鞋专线</a>&nbsp;&nbsp;
      </div>
      <div id="footer-info" class="inner">
             <a href="http://www.618shoe.com/">莆田高仿鞋批发</a>&nbsp;&nbsp;
             公司网站:&nbsp;&nbsp;<a href="http://www.618shoe.com//" target="_blank">http://www.618shoe.com/</a>&nbsp;&nbsp;
             <a href="http://www.618shoe.com/">高仿鞋批发市场</a>
             微信 <img src="/pics/qrcode.jpg" style="width:100px;height:100px;">
      </div>
    </footer>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2012/12/07/thrift-quick-start/" data-id="cja9q2ac8000snh5i0sn8krn4" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mongodb-indexes" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2012/12/06/mongodb-indexes/" class="article-date">
  <time datetime="2012-12-06T13:52:00.000Z" itemprop="datePublished">2012-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MongoDB/">MongoDB</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/12/06/mongodb-indexes/">MongoDB的复合索引</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>MongoDB 支持创建包含一个文档内的多个字段的复合索引。</p>
<p>例如某个主题活动的documents：</p>
<p>db.topic_photos</p>
<pre><code>{
  &quot;_id&quot; : ObjectId(&quot;50b664372115fb21eca4b2b1&quot;),
  &quot;created_at&quot; : ISODate(&quot;2012-11-28T19:21:27.528Z&quot;),
  &quot;featured&quot; : true,
  &quot;featured_at&quot; : ISODate(&quot;2012-12-06T10:17:15.565Z&quot;),
  &quot;featured_by&quot; : NumberLong(234234),
  &quot;last_liked&quot; : ISODate(&quot;2012-12-06T13:51:29.742Z&quot;),
  &quot;likes&quot; : 386,
  &quot;photo_id&quot; : NumberLong(&quot;41136819156557824&quot;),
  &quot;topic_id&quot; : NumberLong(&quot;38362556125028352&quot;),
  &quot;user_id&quot; : NumberLong(3532432)
}
</code></pre><p>为了查询出该主题活动最受欢迎的图片，可以建立包含topic_id ,likes 和 created_at 字段的复合索引。</p>
<pre><code>db.topic_photos.ensureIndex({&quot;topic_id&quot;:1,&quot;likes&quot;:-1,&quot;created_at&quot;:-1})
</code></pre><p>任何使用索引中的前缀字段的查询都能命中复合索引。（Compound indexes support queries on any prefix of the fields in the index. ）举个例子，使用topic_id 或者是 topic_id 和  likes 的查询都能命中索引。<strong>然而，以下查询的情况无法命中索引：</strong></p>
<ul>
<li>只用 likes 查询</li>
<li>只用 created_at 查询</li>
<li>只用 likes 和 created_at 查询</li>
<li>只用 topic_id 和 created_at 查询</li>
</ul>
<p>当创建一个复合索引时，紧随索引字段的数字会指定索引的排序方式。1为升序，-1 为倒序。按何种方式排序并不影响随机访问，但却对利用复合索引进行带排序的查询很重要。</p>
<p>索引字段的顺序也非常关键。在上面的例子中，这个索引会包括首先按照第一个字段topic_id的值 排序，然后再按照likes 的值排序，最后才是按时间created_at 排序。</p>
<p>索引前缀(Index prefixes) 必须是索引字段的子集。例如，创建了索引{a:1, b:1, c:1},使用{a:1} 和 {a:1, b:1} 都是该索引的前缀。</p>
<p><strong>提示</strong>：不用担心查询时字段的顺序。如果写查询语句 find({b:1,a:1}) 还是能够命中索引{a:1, b:1, c:1}。</p>
<p>总结</p>
<p>MongoDB的复合索引采用索引字段的前缀匹配，因此创建复合索引时，索引字段的顺序或 字段本身的排序非常重要。可以使用explain 查看 查询执行时是否命中索引。</p>
<p><strong>对比</strong><br>例如在MySQL 建立 topic_id,likes,created_at 三个字段的复合索引。<br>能够命中索引的查询：</p>
<ul>
<li>单独查询topic_id</li>
<li>查询topic_id and likes</li>
<li>查询topic_id and created_at</li>
<li>查询所有列</li>
</ul>
<p>不能命中索引的查询：</p>
<ul>
<li>单独查询likes</li>
<li>单独查询 created_at</li>
<li>查询 likes 和 created_at</li>
</ul>
<p>参考资料</p>
<ul>
<li><a href="http://docs.mongodb.org/manual/core/indexes/" target="_blank" rel="noopener">Indexing Overview - MongoDB Manual</a></li>
<li><a href="http://leyteris.iteye.com/blog/825799" target="_blank" rel="noopener">关于MySQL中复合索引优化</a></li>
</ul>

      
    </div>
    <footer class="article-footer2">
      <div id="footer-info" class="inner">
        <a href="http://www.618shoe.com/">莆田1:1精仿鞋微信号</a>
        <a href="http://www.618shoe.com/">莆田高仿鞋子的价格表</a>
        <a href="http://www.618shoe.com/">关于莆田仿鞋</a>
        <a href="http://www.618shoe.com/">莆田高仿鞋淘宝店店名</a>
        <a href="http://www.618shoe.com/">莆田精仿鞋官网</a>
         咨询QQ：<a title="点击这里给我发消息" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2727291807&amp;site=www.cactussoft.cn&amp;menu=yes" target="_blank"><img src="http://wpa.qq.com/pa?p=2:2727291807:41"></a>
      </div>
        <div id="footer-info" class="inner">
          <a href="http://www.618shoe.com/">莆田高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">1：1高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">高仿鞋批发市场</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">高仿鞋网</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">广州高仿鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">外贸尾单鞋批发</a>&nbsp;&nbsp;
          <a href="http://www.618shoe.com/">精仿鞋专线</a>&nbsp;&nbsp;
      </div>
      <div id="footer-info" class="inner">
             <a href="http://www.618shoe.com/">莆田高仿鞋批发</a>&nbsp;&nbsp;
             公司网站:&nbsp;&nbsp;<a href="http://www.618shoe.com//" target="_blank">http://www.618shoe.com/</a>&nbsp;&nbsp;
             <a href="http://www.618shoe.com/">高仿鞋批发市场</a>
             微信 <img src="/pics/qrcode.jpg" style="width:100px;height:100px;">
      </div>
    </footer>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2012/12/06/mongodb-indexes/" data-id="cja9q2ac5000pnh5iqa59ns98" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Catégories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/">Architecture</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DevTools/">DevTools</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DevTools-Eclipse/">DevTools Eclipse</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-Btrace/">Java Btrace</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-JVM/">Java JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-MultiThreading/">Java MultiThreading</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-NIO/">Java NIO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-Reflection/">Java Reflection</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-Unicode/">Java Unicode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Shell/">Linux Shell</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MongoDB/">MongoDB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/NSQ-golang/">NSQ golang</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Solr/">Solr</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Solr-Lucene/">Solr Lucene</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Unicode-Python/">Unicode Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git-DevTools/">git DevTools</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/jafka-zookeeper/">jafka zookeeper</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/jsonp-security/">jsonp security</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/thrift/">thrift</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/zookeeper/">zookeeper</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">February 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">August 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">July 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/03/">March 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12/">December 2012</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/11/21/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2015/01/16/process-task-by-queue/">process task by queue</a>
          </li>
        
          <li>
            <a href="/2015/01/15/threadpoolexecutor/">ThreadPoolExecutor 学习笔记</a>
          </li>
        
          <li>
            <a href="/2014/02/19/nsq-internals/">nsq internals</a>
          </li>
        
          <li>
            <a href="/2014/02/18/nsq-design/">nsq design</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
 	<div id="footer-info" class="inner">
     咨询QQ：<a title="点击这里给我发消息" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2727291807&amp;site=www.cactussoft.cn&amp;menu=yes" target="_blank"><img src="http://wpa.qq.com/pa?p=2:2727291807:41"></a>
 	</div>
   	<div id="footer-info" class="inner">
     	<a href="http://www.618shoe.com/">莆田高仿鞋批发</a>&nbsp;&nbsp;
     	<a href="http://www.618shoe.com/">1：1高仿鞋批发</a>&nbsp;&nbsp;
     	<a href="http://www.618shoe.com/">高仿鞋批发市场</a>&nbsp;&nbsp;
     	<a href="http://www.618shoe.com/">高仿鞋网</a>&nbsp;&nbsp;
     	<a href="http://www.618shoe.com/">广州高仿鞋批发</a>&nbsp;&nbsp;
    	<a href="http://www.618shoe.com/">外贸尾单鞋批发</a>&nbsp;&nbsp;
    	<a href="http://www.618shoe.com/">精仿鞋专线</a>&nbsp;&nbsp;
	</div>
 	<div id="footer-info" class="inner">
         <a href="http://www.618shoe.com/">莆田高仿鞋批发微信号</a>&nbsp;&nbsp;
         公司网站:&nbsp;&nbsp;<a href="http://www.618shoe.com//" target="_blank">http://www.618shoe.com/</a>&nbsp;&nbsp;
         <a href="http://www.618shoe.com/">高仿鞋批发市场</a>
         微信 <img src="/pics/qrcode.jpg" style="width:100px;height:100px;">
 	</div>
    <div id="footer-info" class="inner">
      &copy; 2017 Sharewind<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>